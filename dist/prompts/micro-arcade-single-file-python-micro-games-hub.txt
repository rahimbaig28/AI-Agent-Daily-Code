Micro-Arcade: single-file Python micro-games hub

- Purpose: A single-file Python 3 script that bundles a small, testable collection of three keyboard-driven micro-games (Reaction Tap, Grid Dodge, and Memory Pairs) runnable in a terminal/console; keep UI text-based so it’s implementable with only the standard library.  
- Runtime: Python 3.8+ using only standard library modules (curses if available, otherwise fall back to simple stdin/print mode). Detect availability of curses at startup and choose the richer TUI path when possible.  
- Single entrypoint: one executable script file with a main() guarded by if __name__ == "__main__".  
- Game launcher UI: on start show a compact menu listing the three games, high-score viewer, settings, and Quit; navigate with up/down arrows (or j/k) and confirm with Enter; Esc or Ctrl-C returns to launcher or quits.  
- Games (each designed to be short and independently testable):  
  - Reaction Tap: shows a countdown, then displays “GO!” after a random delay (0.8–3.0s). Measure reaction time to the first keypress; show result and whether it’s a personal best. Repeat option.  
  - Grid Dodge: display a small grid (configurable size default 8x6) with a player '@' at bottom center and falling hazards '*' that move downward each tick. Move left/right with arrow keys (or a/d). Collide -> game over; survive for a configurable time or score by dodging; show score and best score. Uses simple tick loop with adjustable speed.  
  - Memory Pairs: create a small NxM card grid (default 4x4) of shuffled letter pairs. Reveal cards with number keys (1..N*M) or arrow/select; match pairs to remove them; track moves and time; show accuracy and best records.  
- Settings (persisted): adjustable options for sound beep on events (terminal beep), difficulty (speed or grid size), and theme preference (force light/dark or auto). Persist settings and per-game high scores in a JSON file stored in the user’s config directory (use appdirs pattern: XDG_CONFIG_HOME or fallback to ~/.config/micro_arcade/config.json). All persistence operations must be safe: atomic write (write temp file then rename).  
- Accessibility & keyboard support: full keyboard navigation; alternative letter-key controls if arrow keys unavailable; clear text prompts; readable color fallback to monochrome if terminal lacks color. Provide large-font ASCII title and concise on-screen instructions before each game starts.  
- Visuals & responsiveness: layout scales to terminal size where possible (curses) — clamp grid sizes to available rows/cols; if terminal too small, show a clear message instructing user to enlarge terminal or switch to fallback mode.  
- Print-friendly / shareable results: provide a command-line flag (--report) to output the last-played game summary (game name, score/time, date/time, and personal-best status) as plain text suitable for printing or piping to a file.  
- Dark/light auto theme: detect terminal background brightness heuristically via environment variables (TERM) or user setting; map color pairs accordingly; settings allow override.  
- Structure & modularity (single-file): implement clear function separation (main menu, each game as function/class, settings persistence helpers, terminal abstraction layer that wraps curses or fallback simple IO). Keep code compact and linear so the whole app remains a single file and implementable under ~1000 lines.  
- Error handling & portability: graceful fallback if curses unavailable or on Windows (use msvcrt.getch for key reads on Windows). Catch exceptions and save state before exit. Provide --no-curses flag to force fallback mode.  
- Tests & demo mode: include a --demo flag that runs short automated plays of each game (no user input) to verify mechanics and persistence; return exit code 0 on success.  
- Usage examples (CLI):  
  - Run interactive launcher: python micro_arcade.py  
  - Print last result: python micro_arcade.py --report  
  - Force fallback mode: python micro_arcade.py --no-curses  
  - Run demo: python micro_arcade.py --demo  
- Implementation notes for developer: keep dependencies to the stdlib (json, time, random, os, sys, argparse, tempfile, shutil, pathlib, datetime, curses, msvcrt when needed). Use simple data structures for high scores (per-game dict with best score/time and timestamp). Ensure the entire app fits one file, uses atomic JSON saves, and limits per-frame CPU usage with time.sleep to avoid busy loops.

(Generated: 2025-12-17T01:23:19.895268Z, seed=32067, theme=micro games, extras=print-friendly view, responsive grid, dark/light auto theme, kind=py)
