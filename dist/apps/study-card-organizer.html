<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-12-09T01:25:21.509595Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Study Card Organizer</title>
<style>
  :root {
    --card-bg: #fff;
    --card-border: #ccc;
    --card-shadow: rgba(0,0,0,0.1);
    --primary-color: #0366d6;
    --focus-outline: 2px solid #0366d6;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 1rem; background: #f9f9f9;
    font-family: var(--font-family);
    color: #222;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }
  h1 {
    font-weight: 600;
    font-size: 1.5rem;
    margin: 0;
  }
  #toolbar {
    display: flex;
    gap: 0.5rem;
  }
  button {
    background: var(--primary-color);
    border: none;
    color: white;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.2s ease;
  }
  button:disabled {
    background: #999;
    cursor: default;
  }
  button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  main {
    flex-grow: 1;
  }
  #cards-container {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(220px,1fr));
    gap: 1rem;
  }
  .card {
    perspective: 1000px;
    cursor: pointer;
    outline-offset: 2px;
  }
  .card:focus-visible {
    outline: var(--focus-outline);
  }
  .card-inner {
    position: relative;
    width: 100%;
    min-height: 140px;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 8px;
    box-shadow: 0 2px 6px var(--card-shadow);
    transition: transform 0.5s;
    transform-style: preserve-3d;
    user-select: none;
  }
  .card.flipped .card-inner {
    transform: rotateY(180deg);
  }
  .card-front, .card-back {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    padding: 1rem;
    backface-visibility: hidden;
    overflow-wrap: break-word;
    display: flex;
    flex-direction: column;
  }
  .card-front {
    background: var(--card-bg);
    color: #111;
  }
  .card-back {
    background: #e8f0fe;
    color: #111;
    transform: rotateY(180deg);
  }
  .card textarea {
    width: 100%;
    resize: vertical;
    border: none;
    background: transparent;
    font-family: var(--font-family);
    font-size: 1rem;
    color: inherit;
    outline-offset: 2px;
    padding: 0;
    margin: 0;
    line-height: 1.3;
    min-height: 2.5rem;
  }
  .card textarea:focus {
    outline: var(--focus-outline);
    background: #fff;
  }
  .card-controls {
    margin-top: auto;
    display: flex;
    justify-content: flex-end;
    gap: 0.25rem;
  }
  .card-controls button {
    background: transparent;
    border: none;
    color: var(--primary-color);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.1rem 0.3rem;
    user-select: none;
    border-radius: 4px;
  }
  .card-controls button:focus-visible {
    outline: var(--focus-outline);
  }
  .card-controls button:hover {
    background: #dbe9ff;
  }
  @media (max-width: 480px) {
    body {
      padding: 0.5rem;
    }
    button {
      padding: 0.4rem 0.7rem;
      font-size: 0.9rem;
    }
  }
</style>
</head>
<body>
<header>
  <h1 id="app-title">Study Card Organizer</h1>
  <nav id="toolbar" role="toolbar" aria-label="Card actions">
    <button id="add-card-btn" aria-label="Add new card" type="button">Add Card</button>
    <button id="undo-btn" aria-label="Undo last action" type="button" disabled>Undo</button>
    <button id="redo-btn" aria-label="Redo last undone action" type="button" disabled>Redo</button>
    <button id="clear-btn" aria-label="Clear all cards" type="button">Clear All</button>
  </nav>
</header>
<main>
  <section id="cards-container" role="list" aria-label="Study cards"></section>
</main>
<script>
(() => {
  "use strict";

  // Data model: array of cards {id, front, back}
  // State: cards array, undoStack, redoStack
  let cards = [];
  let undoStack = [];
  let redoStack = [];

  // DOM references
  const cardsContainer = document.getElementById("cards-container");
  const addCardBtn = document.getElementById("add-card-btn");
  const undoBtn = document.getElementById("undo-btn");
  const redoBtn = document.getElementById("redo-btn");
  const clearBtn = document.getElementById("clear-btn");

  // Helpers
  function saveToStorage() {
    localStorage.setItem("studyCards", JSON.stringify(cards));
  }
  function loadFromStorage() {
    try {
      const data = localStorage.getItem("studyCards");
      if (data) {
        cards = JSON.parse(data);
      }
    } catch {
      cards = [];
    }
  }
  function saveStateForUndo() {
    undoStack.push(JSON.stringify(cards));
    // Limit undo stack size to 100
    if (undoStack.length > 100) undoStack.shift();
    redoStack = [];
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }
  function generateId() {
    return "c" + Math.random().toString(36).slice(2, 10);
  }

  // Render cards
  function renderCards() {
    cardsContainer.innerHTML = "";
    cards.forEach((card, index) => {
      const cardEl = createCardElement(card, index);
      cardsContainer.appendChild(cardEl);
    });
  }

  // Create card element with accessibility and editing
  function createCardElement(card, index) {
    const cardEl = document.createElement("article");
    cardEl.className = "card";
    cardEl.setAttribute("role", "listitem");
    cardEl.setAttribute("tabindex", "0");
    cardEl.setAttribute("aria-label", `Card ${index + 1}`);
    cardEl.dataset.id = card.id;
    cardEl.dataset.index = index;

    // Inner container for flip animation
    const inner = document.createElement("div");
    inner.className = "card-inner";
    cardEl.appendChild(inner);

    // Front side
    const front = document.createElement("section");
    front.className = "card-front";
    front.setAttribute("aria-hidden", "false");
    inner.appendChild(front);

    const frontTextarea = document.createElement("textarea");
    frontTextarea.value = card.front;
    frontTextarea.setAttribute("aria-label", `Front of card ${index + 1} (question)`);
    frontTextarea.spellcheck = false;
    front.appendChild(frontTextarea);

    // Back side
    const back = document.createElement("section");
    back.className = "card-back";
    back.setAttribute("aria-hidden", "true");
    inner.appendChild(back);

    const backTextarea = document.createElement("textarea");
    backTextarea.value = card.back;
    backTextarea.setAttribute("aria-label", `Back of card ${index + 1} (answer)`);
    backTextarea.spellcheck = false;
    back.appendChild(backTextarea);

    // Controls for edit/delete
    const controls = document.createElement("div");
    controls.className = "card-controls";
    front.appendChild(controls);

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.title = "Delete card";
    deleteBtn.setAttribute("aria-label", `Delete card ${index + 1}`);
    deleteBtn.innerHTML = "ðŸ—‘ï¸";
    controls.appendChild(deleteBtn);

    // State for flipped
    let flipped = false;

    // Flip toggle function
    function toggleFlip() {
      flipped = !flipped;
      if (flipped) {
        cardEl.classList.add("flipped");
        front.setAttribute("aria-hidden", "true");
        back.setAttribute("aria-hidden", "false");
      } else {
        cardEl.classList.remove("flipped");
        front.setAttribute("aria-hidden", "false");
        back.setAttribute("aria-hidden", "true");
      }
    }

    // Click or keyboard to flip
    cardEl.addEventListener("click", (e) => {
      // Prevent flipping if clicking inside textarea or buttons
      if (
        e.target === frontTextarea ||
        e.target === backTextarea ||
        e.target === deleteBtn
      ) return;
      toggleFlip();
    });
    cardEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
        e.preventDefault();
        toggleFlip();
      }
    });

    // Editing handlers with autosave and undo stack
    function onEdit() {
      const newFront = frontTextarea.value.trim();
      const newBack = backTextarea.value.trim();
      if (newFront !== card.front || newBack !== card.back) {
        saveStateForUndo();
        card.front = newFront;
        card.back = newBack;
        saveToStorage();
      }
    }
    frontTextarea.addEventListener("input", onEdit);
    backTextarea.addEventListener("input", onEdit);

    // Delete card handler
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      saveStateForUndo();
      cards = cards.filter((c) => c.id !== card.id);
      saveToStorage();
      renderCards();
    });

    // Drag and drop attributes
    cardEl.setAttribute("draggable", "true");

    cardEl.addEventListener("dragstart", (e) => {
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", card.id);
      cardEl.classList.add("dragging");
    });
    cardEl.addEventListener("dragend", () => {
      cardEl.classList.remove("dragging");
    });

    return cardEl;
  }

  // Drag and drop reorder logic
  cardsContainer.addEventListener("dragover", (e) => {
    e.preventDefault();
    const draggingEl = cardsContainer.querySelector(".dragging");
    if (!draggingEl) return;

    const afterElement = getDragAfterElement(cardsContainer, e.clientY);
    if (afterElement == null) {
      cardsContainer.appendChild(draggingEl);
    } else {
      cardsContainer.insertBefore(draggingEl, afterElement);
    }
  });

  cardsContainer.addEventListener("drop", (e) => {
    e.preventDefault();
    const draggingEl = cardsContainer.querySelector(".dragging");
    if (!draggingEl) return;
    draggingEl.classList.remove("dragging");

    // Update cards order according to DOM order
    const newOrderIds = Array.from(cardsContainer.children).map((el) =>
      el.dataset.id
    );
    if (!arraysEqual(newOrderIds, cards.map((c) => c.id))) {
      saveStateForUndo();
      cards = newOrderIds.map((id) => cards.find((c) => c.id === id));
      saveToStorage();
      renderCards();
    }
  });

  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll(".card:not(.dragging)")];
    return draggableElements.reduce(
      (closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      },
      { offset: Number.NEGATIVE_INFINITY }
    ).element;
  }

  function arraysEqual(a1, a2) {
    if (a1.length !== a2.length) return false;
    for (let i = 0; i < a1.length; i++) {
      if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  // Toolbar button handlers
  addCardBtn.addEventListener("click", () => {
    saveStateForUndo();
    const newCard = { id: generateId(), front: "", back: "" };
    cards.push(newCard);
    saveToStorage();
    renderCards();
    // Focus new card front textarea after render
    setTimeout(() => {
      const lastCard = cardsContainer.lastElementChild;
      if (lastCard) {
        const textarea = lastCard.querySelector(".card-front textarea");
        if (textarea) textarea.focus();
      }
    }, 0);
  });

  undoBtn.addEventListener("click", () => {
    if (undoStack.length === 0) return;
    redoStack.push(JSON.stringify(cards));
    const prev = undoStack.pop();
    cards = JSON.parse(prev);
    saveToStorage();
    renderCards();
    updateUndoRedoButtons();
  });

  redoBtn.addEventListener("click", () => {
    if (redoStack.length === 0) return;
    undoStack.push(JSON.stringify(cards));
    const next = redoStack.pop();
    cards = JSON.parse(next);
    saveToStorage();
    renderCards();
    updateUndoRedoButtons();
  });

  clearBtn.addEventListener("click", () => {
    if (confirm("Are you sure you want to clear all cards? This action cannot be undone.")) {
      saveStateForUndo();
      cards = [];
      saveToStorage();
      renderCards();
    }
  });

  // Keyboard shortcuts for undo/redo
  window.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === "z") {
      e.preventDefault();
      undoBtn.click();
    } else if (((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") ||
               ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "z")) {
      e.preventDefault();
      redoBtn.click();
    }
  });

  // Initialization
  loadFromStorage();
  renderCards();
  updateUndoRedoButtons();
})();
</script>
</body>
</html>