<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-12-04T13:36:07.413711Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Research Paper Organizer</title>
<style>
  :root {
    --color-bg-light: #f9f9f9;
    --color-bg-dark: #121212;
    --color-text-light: #222;
    --color-text-dark: #eee;
    --color-primary: #0066cc;
    --color-primary-dark: #3399ff;
    --color-error: #d93025;
    --color-star: #f5c518;
    --color-tag-bg: #e0e0e0;
    --color-tag-bg-dark: #333;
    --focus-outline: 3px solid #3399ff;
  }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    background-color: var(--color-bg-light);
    color: var(--color-text-light);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  body.dark {
    background-color: var(--color-bg-dark);
    color: var(--color-text-dark);
  }
  header {
    position: sticky;
    top: 0;
    background: inherit;
    border-bottom: 1px solid #ccc;
    border-color: var(--color-bg-dark);
    padding: 0.5rem 1rem;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
    z-index: 10;
  }
  body.dark header {
    border-color: #444;
  }
  header input[type="search"] {
    flex: 1 1 250px;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid #999;
    border-radius: 4px;
    background: inherit;
    color: inherit;
  }
  body.dark header input[type="search"] {
    border-color: #666;
  }
  header button {
    background-color: var(--color-primary);
    border: none;
    color: white;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
    flex-shrink: 0;
  }
  header button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  body.dark header button {
    background-color: var(--color-primary-dark);
  }
  main {
    flex: 1 1 auto;
    padding: 1rem;
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  @media (min-width: 600px) {
    main {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  .card {
    background-color: #fff;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgb(0 0 0 / 0.1);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    color: var(--color-text-light);
  }
  body.dark .card {
    background-color: #222;
    color: var(--color-text-dark);
    box-shadow: 0 1px 4px rgb(255 255 255 / 0.1);
  }
  .card h2 {
    margin: 0;
    font-size: 1.2rem;
    line-height: 1.2;
  }
  .card .authors-year {
    font-size: 0.9rem;
    color: #555;
  }
  body.dark .card .authors-year {
    color: #bbb;
  }
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .tag {
    background-color: var(--color-tag-bg);
    color: #333;
    font-size: 0.75rem;
    padding: 0.15rem 0.4rem;
    border-radius: 3px;
  }
  body.dark .tag {
    background-color: var(--color-tag-bg-dark);
    color: #ddd;
  }
  .star-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--color-star);
    font-size: 1.2rem;
    align-self: flex-start;
    padding: 0;
  }
  .star-btn[aria-pressed="false"] {
    color: #bbb;
  }
  .star-btn:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  .note-preview {
    font-size: 0.85rem;
    color: #444;
    white-space: pre-wrap;
    max-height: 3.6em;
    overflow: hidden;
  }
  body.dark .note-preview {
    color: #ccc;
  }
  .empty-state {
    grid-column: 1 / -1;
    text-align: center;
    font-size: 1.1rem;
    color: #666;
  }
  body.dark .empty-state {
    color: #999;
  }
  /* Modal */
  .modal-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(0,0,0,0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }
  .modal-backdrop.active {
    display: flex;
  }
  .modal {
    background-color: #fff;
    border-radius: 8px;
    max-width: 600px;
    width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    padding: 1rem 1.5rem 1.5rem 1.5rem;
    box-shadow: 0 4px 12px rgb(0 0 0 / 0.3);
    color: var(--color-text-light);
  }
  body.dark .modal {
    background-color: #222;
    color: var(--color-text-dark);
    box-shadow: 0 4px 12px rgb(255 255 255 / 0.3);
  }
  .modal h3 {
    margin-top: 0;
  }
  .modal form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  label {
    font-weight: 600;
    display: block;
    margin-bottom: 0.2rem;
  }
  input[type="text"],
  input[type="url"],
  input[type="number"],
  textarea {
    width: 100%;
    font-size: 1rem;
    padding: 0.3rem 0.5rem;
    border: 1px solid #999;
    border-radius: 4px;
    background: inherit;
    color: inherit;
    resize: vertical;
  }
  body.dark input[type="text"],
  body.dark input[type="url"],
  body.dark input[type="number"],
  body.dark textarea {
    border-color: #666;
  }
  input:focus-visible,
  textarea:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  .error-message {
    color: var(--color-error);
    font-size: 0.85rem;
  }
  .modal-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }
  .modal-buttons button {
    padding: 0.4rem 1rem;
    font-size: 1rem;
    border-radius: 4px;
    border: none;
    cursor: pointer;
  }
  .modal-buttons button[type="submit"] {
    background-color: var(--color-primary);
    color: white;
  }
  body.dark .modal-buttons button[type="submit"] {
    background-color: var(--color-primary-dark);
  }
  .modal-buttons button.cancel-btn {
    background-color: #ccc;
    color: #222;
  }
  body.dark .modal-buttons button.cancel-btn {
    background-color: #444;
    color: var(--color-text-dark);
  }
  .tags-input {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    border: 1px solid #999;
    border-radius: 4px;
    padding: 0.3rem 0.5rem;
    background: inherit;
    color: inherit;
  }
  body.dark .tags-input {
    border-color: #666;
  }
  .tags-input input {
    border: none;
    background: transparent;
    color: inherit;
    font-size: 1rem;
    flex: 1 1 120px;
    min-width: 60px;
  }
  .tags-input input:focus-visible {
    outline: none;
  }
  .tag-pill {
    background-color: var(--color-tag-bg);
    color: #333;
    border-radius: 12px;
    padding: 0 0.5rem;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }
  body.dark .tag-pill {
    background-color: var(--color-tag-bg-dark);
    color: #ddd;
  }
  .tag-pill button {
    background: none;
    border: none;
    cursor: pointer;
    color: inherit;
    font-weight: 700;
    font-size: 1rem;
    line-height: 1;
    padding: 0;
  }
  .tag-pill button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: 2px;
  }
  /* Scrollbar for modal */
  .modal::-webkit-scrollbar {
    width: 8px;
  }
  .modal::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 4px;
  }
  body.dark .modal::-webkit-scrollbar-thumb {
    background-color: #555;
  }
</style>
</head>
<body>
<header role="banner">
  <label for="search" class="visually-hidden">Search papers</label>
  <input type="search" id="search" aria-label="Search papers" placeholder="Search papers..." autocomplete="off" />
  <button id="addBtn" aria-label="Add new paper" type="button">Add Paper</button>
  <button id="exportBtn" aria-label="Export papers" type="button">Export</button>
  <button id="themeToggleBtn" aria-label="Toggle dark/light theme" type="button">Toggle Theme</button>
</header>
<main role="main" aria-live="polite" aria-relevant="additions removals" aria-atomic="true">
  <p class="empty-state" id="emptyStateMsg" tabindex="0">No papers added yet. Use "Add Paper" to start cataloging your research.</p>
</main>

<div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalDesc" hidden>
  <div class="modal" role="document">
    <h3 id="modalTitle">Add Paper</h3>
    <form id="paperForm" novalidate>
      <input type="hidden" id="paperId" />
      <div>
        <label for="titleInput">Title <span aria-hidden="true">*</span></label>
        <input type="text" id="titleInput" name="title" aria-required="true" aria-describedby="titleError" autocomplete="off" />
        <div id="titleError" class="error-message" aria-live="assertive"></div>
      </div>
      <div>
        <label for="authorsInput">Authors <span aria-hidden="true">*</span></label>
        <input type="text" id="authorsInput" name="authors" aria-required="true" aria-describedby="authorsError" placeholder="Separate authors by commas" autocomplete="off" />
        <div id="authorsError" class="error-message" aria-live="assertive"></div>
      </div>
      <div>
        <label for="yearInput">Year <span aria-hidden="true">*</span></label>
        <input type="number" id="yearInput" name="year" aria-required="true" aria-describedby="yearError" min="1000" max="9999" step="1" autocomplete="off" />
        <div id="yearError" class="error-message" aria-live="assertive"></div>
      </div>
      <div>
        <label for="doiInput">DOI or URL</label>
        <input type="url" id="doiInput" name="doi" aria-describedby="doiError" placeholder="https:// or DOI link" autocomplete="off" />
        <div id="doiError" class="error-message" aria-live="assertive"></div>
      </div>
      <div>
        <label for="abstractInput">Abstract</label>
        <textarea id="abstractInput" name="abstract" rows="4" autocomplete="off"></textarea>
      </div>
      <div>
        <label for="tagsInput">Tags</label>
        <div class="tags-input" id="tagsInput" aria-label="Tags input" role="list" tabindex="0"></div>
      </div>
      <div>
        <label for="notesInput">Personal Notes & Highlights</label>
        <textarea id="notesInput" name="notes" rows="4" autocomplete="off"></textarea>
      </div>
      <div>
        <label for="starredInput">
          <input type="checkbox" id="starredInput" name="starred" />
          Mark as Favorite
        </label>
      </div>
      <div class="modal-buttons">
        <button type="submit" id="saveBtn">Save</button>
        <button type="button" class="cancel-btn" id="cancelBtn">Cancel</button>
      </div>
    </form>
  </div>
</div>

<script>
  (() => {
    "use strict";

    // Utilities
    function el(id) { return document.getElementById(id); }
    function createEl(tag, attrs = {}, ...children) {
      const e = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") e.className = v;
        else if (k === "aria-pressed" || k.startsWith("aria-")) e.setAttribute(k, v);
        else if (k === "htmlFor") e.htmlFor = v;
        else if (k === "type" && v === "checkbox") e.type = "checkbox";
        else e[k] = v;
      }
      for (const c of children) {
        if (typeof c === "string") e.appendChild(document.createTextNode(c));
        else if (c) e.appendChild(c);
      }
      return e;
    }
    function sanitizeText(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
    function debounce(fn, delay) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
      };
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    // Data keys
    const STORAGE_KEY = "rpo_papers";
    const THEME_KEY = "rpo_theme";
    const UNDO_STACK_KEY = "rpo_undo_stack";
    const REDO_STACK_KEY = "rpo_redo_stack";

    // Undo/Redo stack max size
    const MAX_STACK_SIZE = 20;

    // Elements
    const mainEl = document.querySelector("main");
    const emptyStateMsg = el("emptyStateMsg");
    const searchInput = el("search");
    const addBtn = el("addBtn");
    const exportBtn = el("exportBtn");
    const themeToggleBtn = el("themeToggleBtn");
    const modalBackdrop = el("modalBackdrop");
    const modalTitle = el("modalTitle");
    const paperForm = el("paperForm");
    const cancelBtn = el("cancelBtn");
    const paperIdInput = el("paperId");
    const titleInput = el("titleInput");
    const authorsInput = el("authorsInput");
    const yearInput = el("yearInput");
    const doiInput = el("doiInput");
    const abstractInput = el("abstractInput");
    const tagsInput = el("tagsInput");
    const notesInput = el("notesInput");
    const starredInput = el("starredInput");
    const saveBtn = el("saveBtn");

    // Error message elements
    const titleError = el("titleError");
    const authorsError = el("authorsError");
    const yearError = el("yearError");
    const doiError = el("doiError");

    // State
    let papers = [];
    let filteredPapers = [];
    let undoStack = [];
    let redoStack = [];
    let currentTheme = "light";

    // Tags input state
    let tags = [];

    // Accessibility helper: visually hidden class
    const style = document.createElement("style");
    style.textContent = `.visually-hidden { position: absolute !important; width: 1px !important; height: 1px !important; padding: 0 !important; margin: -1px !important; overflow: hidden !important; clip: rect(0,0,0,0) !important; border: 0 !important; }`;
    document.head.appendChild(style);

    // Initialize
    function init() {
      loadTheme();
      loadData();
      loadUndoRedo();
      renderPapers();
      attachEventListeners();
      updateEmptyState();
    }

    // Load theme from localStorage
    function loadTheme() {
      const saved = localStorage.getItem(THEME_KEY);
      if (saved === "dark") {
        currentTheme = "dark";
        document.body.classList.add("dark");
      } else {
        currentTheme = "light";
        document.body.classList.remove("dark");
      }
      updateThemeButton();
    }

    function updateThemeButton() {
      themeToggleBtn.textContent = currentTheme === "dark" ? "Light Theme" : "Dark Theme";
      themeToggleBtn.setAttribute("aria-pressed", currentTheme === "dark" ? "true" : "false");
    }

    // Toggle theme
    function toggleTheme() {
      if (currentTheme === "light") {
        currentTheme = "dark";
        document.body.classList.add("dark");
      } else {
        currentTheme = "light";
        document.body.classList.remove("dark");
      }
      localStorage.setItem(THEME_KEY, currentTheme);
      updateThemeButton();
    }

    // Load papers from localStorage
    function loadData() {
      try {
        const data = localStorage.getItem(STORAGE_KEY);
        if (data) {
          papers = JSON.parse(data);
        } else {
          papers = [];
        }
      } catch {
        papers = [];
      }
      filteredPapers = papers.slice();
    }

    // Save papers to localStorage
    function saveData() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(papers));
    }

    // Load undo/redo stacks
    function loadUndoRedo() {
      try {
        const undoData = localStorage.getItem(UNDO_STACK_KEY);
        const redoData = localStorage.getItem(REDO_STACK_KEY);
        undoStack = undoData ? JSON.parse(undoData) : [];
        redoStack = redoData ? JSON.parse(redoData) : [];
      } catch {
        undoStack = [];
        redoStack = [];
      }
    }

    // Save undo/redo stacks
    function saveUndoRedo() {
      localStorage.setItem(UNDO_STACK_KEY, JSON.stringify(undoStack));
      localStorage.setItem(REDO_STACK_KEY, JSON.stringify(redoStack));
    }

    // Push state to undo stack
    function pushUndo() {
      undoStack.push(deepClone(papers));
      if (undoStack.length > MAX_STACK_SIZE) undoStack.shift();
      redoStack = [];
      saveUndoRedo();
    }

    // Undo operation
    function undo() {
      if (undoStack.length === 0) return;
      redoStack.push(deepClone(papers));
      papers = undoStack.pop();
      saveData();
      saveUndoRedo();
      filteredPapers = papers.slice();
      renderPapers();
      updateEmptyState();
    }

    // Redo operation
    function redo() {
      if (redoStack.length === 0) return;
      undoStack.push(deepClone(papers));
      papers = redoStack.pop();
      saveData();
      saveUndoRedo();
      filteredPapers = papers.slice();
      renderPapers();
      updateEmptyState();
    }

    // Generate unique ID
    function generateId() {
      return "p" + Date.now() + Math.random().toString(36).slice(2, 8);
    }

    // Render papers list
    function renderPapers() {
      mainEl.innerHTML = "";
      if (filteredPapers.length === 0) {
        mainEl.appendChild(emptyStateMsg);
        emptyStateMsg.style.display = "block";
        emptyStateMsg.focus();
        return;
      }
      emptyStateMsg.style.display = "none";
      filteredPapers.forEach(paper => {
        const card = createPaperCard(paper);
        mainEl.appendChild(card);
      });
    }

    // Create a paper card element
    function createPaperCard(p) {
      const card = createEl("article", { class: "card", tabIndex: 0, role: "region", "aria-label": `Paper titled ${p.title}` });

      // Title and star button container
      const titleStarDiv = createEl("div", { style: "display:flex; justify-content:space-between; align-items:center;" });
      const titleEl = createEl("h2", {}, p.title);
      const starBtn = createEl("button", {
        class: "star-btn",
        "aria-label": p.starred ? "Unfavorite paper" : "Favorite paper",
        "aria-pressed": p.starred ? "true" : "false",
        type: "button",
        title: p.starred ? "Unfavorite paper" : "Favorite paper"
      }, p.starred ? "★" : "☆");
      starBtn.addEventListener("click", e => {
        e.stopPropagation();
        toggleStar(p.id);
      });
      titleStarDiv.appendChild(titleEl);
      titleStarDiv.appendChild(starBtn);
      card.appendChild(titleStarDiv);

      // Authors and year
      const authorsYear = createEl("p", { class: "authors-year" }, `${p.authors} (${p.year})`);
      card.appendChild(authorsYear);

      // Tags
      if (p.tags.length > 0) {
        const tagsDiv = createEl("div", { class: "tags", "aria-label": "Tags" });
        p.tags.forEach(tag => {
          const tagEl = createEl("span", { class: "tag" }, tag);
          tagsDiv.appendChild(tagEl);
        });
        card.appendChild(tagsDiv);
      }

      // Note preview
      if (p.notes.trim()) {
        const notePreview = createEl("p", { class: "note-preview" }, p.notes.trim());
        card.appendChild(notePreview);
      }

      // Click to edit
      card.addEventListener("click", () => openEditModal(p.id));
      card.addEventListener("keydown", e => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          openEditModal(p.id);
        }
      });

      return card;
    }

    // Toggle star/favorite for a paper
    function toggleStar(id) {
      pushUndo();
      const idx = papers.findIndex(p => p.id === id);
      if (idx === -1) return;
      papers[idx].starred = !papers[idx].starred;
      saveData();
      filteredPapers = papers.slice();
      renderPapers();
      updateEmptyState();
    }

    // Open modal for adding new paper
    function openAddModal() {
      modalTitle.textContent = "Add Paper";
      paperForm.reset();
      paperIdInput.value = "";
      tags = [];
      renderTagsInput();
      clearErrors();
      openModal();
    }

    // Open modal for editing paper by id
    function openEditModal(id) {
      const paper = papers.find(p => p.id === id);
      if (!paper) return;
      modalTitle.textContent = "Edit Paper";
      paperIdInput.value = paper.id;
      titleInput.value = paper.title;
      authorsInput.value = paper.authors;
      yearInput.value = paper.year;
      doiInput.value = paper.doi;
      abstractInput.value = paper.abstract;
      notesInput.value = paper.notes;
      starredInput.checked = paper.starred;
      tags = paper.tags.slice();
      renderTagsInput();
      clearErrors();
      openModal();
    }

    // Open modal dialog
    function openModal() {
      modalBackdrop.hidden = false;
      modalBackdrop.classList.add("active");
      titleInput.focus();
      trapFocus(modalBackdrop);
    }

    // Close modal dialog
    function closeModal() {
      modalBackdrop.hidden = true;
      modalBackdrop.classList.remove("active");
      releaseFocusTrap();
      addBtn.focus();
    }

    // Clear form error messages
    function clearErrors() {
      titleError.textContent = "";
      authorsError.textContent = "";
      yearError.textContent = "";
      doiError.textContent = "";
      titleInput.removeAttribute("aria-invalid");
      authorsInput.removeAttribute("aria-invalid");
      yearInput.removeAttribute("aria-invalid");
      doiInput.removeAttribute("aria-invalid");
    }

    // Validate form inputs, return boolean
    function validateForm() {
      clearErrors();
      let valid = true;
      if (!titleInput.value.trim()) {
        titleError.textContent = "Title is required.";
        titleInput.setAttribute("aria-invalid", "true");
        valid = false;
      }
      if (!authorsInput.value.trim()) {
        authorsError.textContent = "Authors are required.";
        authorsInput.setAttribute("aria-invalid", "true");
        valid = false;
      }
      const yearVal = parseInt(yearInput.value, 10);
      if (!yearInput.value.trim() || isNaN(yearVal) || yearVal < 1000 || yearVal > 9999) {
        yearError.textContent = "Enter a valid year (1000-9999).";
        yearInput.setAttribute("aria-invalid", "true");
        valid = false;
      }
      if (doiInput.value.trim()) {
        try {
          // Accept DOI or URL format loosely
          const val = doiInput.value.trim();
          if (!val.startsWith("http") && !val.match(/^10\.\d{4,9}\/[-._;()/:A-Z0-9]+$/i)) {
            throw new Error("Invalid DOI or URL");
          }
          // URL constructor for validation if starts with http
          if (val.startsWith("http")) new URL(val);
        } catch {
          doiError.textContent = "Enter a valid DOI or URL.";
          doiInput.setAttribute("aria-invalid", "true");
          valid = false;
        }
      }
      return valid;
    }

    // Save form data (add or edit)
    function saveFormData() {
      if (!validateForm()) return false;
      const id = paperIdInput.value || generateId();
      const newPaper = {
        id,
        title: titleInput.value.trim(),
        authors: authorsInput.value.trim(),
        year: parseInt(yearInput.value, 10),
        doi: doiInput.value.trim(),
        abstract: abstractInput.value.trim(),
        tags: tags.slice(),
        notes: notesInput.value.trim(),
        starred: starredInput.checked,
        createdAt: paperIdInput.value ? papers.find(p => p.id === id)?.createdAt || Date.now() : Date.now()
      };
      pushUndo();
      const idx = papers.findIndex(p => p.id === id);
      if (idx === -1) {
        papers.push(newPaper);
      } else {
        papers[idx] = newPaper;
      }
      saveData();
      filteredPapers = papers.slice();
      renderPapers();
      updateEmptyState();
      return true;
    }

    // Update empty state message visibility
    function updateEmptyState() {
      if (papers.length === 0) {
        emptyStateMsg.style.display = "block";
      } else {
        emptyStateMsg.style.display = "none";
      }
    }

    // Search papers by all fields, real-time filtering
    function searchPapers(query) {
      const q = query.trim().toLowerCase();
      if (!q) {
        filteredPapers = papers.slice();
      } else {
        filteredPapers = papers.filter(p => {
          return (
            p.title.toLowerCase().includes(q) ||
            p.authors.toLowerCase().includes(q) ||
            String(p.year).includes(q) ||
            p.doi.toLowerCase().includes(q) ||
            p.abstract.toLowerCase().includes(q) ||
            p.tags.some(t => t.toLowerCase().includes(q)) ||
            p.notes.toLowerCase().includes(q)
          );
        });
      }
      renderPapers();
      updateEmptyState();
    }

    // Export papers as plain text or JSON
    function exportPapers() {
      if (papers.length === 0) {
        alert("No papers to export.");
        return;
      }
      const exportFormat = prompt("Export format: Enter 'json' or 'text'", "json");
      if (!exportFormat) return;
      if (exportFormat.toLowerCase() === "json") {
        const jsonStr = JSON.stringify(papers, null, 2);
        downloadFile("papers_export.json", "application/json", jsonStr);
      } else if (exportFormat.toLowerCase() === "text") {
        const text = papers.map(p => {
          return `Title: ${p.title}\nAuthors: ${p.authors}\nYear: ${p.year}\nDOI/URL: ${p.doi}\nTags: ${p.tags.join(", ")}\nNotes: ${p.notes}\nAbstract:\n${p.abstract}\n---`;
        }).join("\n\n");
        downloadFile("papers_export.txt", "text/plain", text);
      } else {
        alert("Invalid export format. Please enter 'json' or 'text'.");
      }
    }

    // Download helper
    function downloadFile(filename, mime, content) {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    // Tags input rendering and logic
    function renderTagsInput() {
      tagsInput.innerHTML = "";
      tags.forEach((tag, i) => {
        const tagEl = createEl("span", { class: "tag-pill", role: "listitem" }, tag);
        const removeBtn = createEl("button", {
          type: "button",
          "aria-label": `Remove tag ${tag}`,
          title: `Remove tag ${tag}`
        }, "×");
        removeBtn.addEventListener("click", e => {
          e.stopPropagation();
          tags.splice(i, 1);
          renderTagsInput();
        });
        tagEl.appendChild(removeBtn);
        tagsInput.appendChild(tagEl);
      });
      const input = createEl("input", {
        type: "text",
        "aria-label": "Add tag",
        placeholder: "Add tag and press Enter",
        autocomplete: "off"
      });
      input.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          const val = input.value.trim();
          if (val && !tags.includes(val)) {
            tags.push(val);
            renderTagsInput();
          }
          input.value = "";
        } else if (e.key === "Escape") {
          e.preventDefault();
          input.value = "";
        }
      });
      tagsInput.appendChild(input);
      input.focus();
    }

    // Keyboard shortcuts and focus trap
    let focusTrapElements = [];
    let lastFocusedElement = null;

    function trapFocus(container) {
      focusTrapElements = Array.from(container.querySelectorAll("input, button, textarea, select, [tabindex]:not([tabindex='-1'])"))
        .filter(el => !el.disabled && el.offsetParent !== null);
      if (focusTrapElements.length === 0) return;
      lastFocusedElement = document.activeElement;
      container.addEventListener("keydown", handleFocusTrap);
    }

    function releaseFocusTrap() {
      modalBackdrop.removeEventListener("keydown", handleFocusTrap);
      if (lastFocusedElement) lastFocusedElement.focus();
    }

    function handleFocusTrap(e) {
      if (e.key !== "Tab") return;
      const first = focusTrapElements;
      const last = focusTrapElements[focusTrapElements.length - 1];
      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    }

    // Event listeners
    function attachEventListeners() {
      addBtn.addEventListener("click", openAddModal);
      cancelBtn.addEventListener("click", e => {
        e.preventDefault();
        closeModal();
      });
      paperForm.addEventListener("submit", e => {
        e.preventDefault();
        if (saveFormData()) closeModal();
      });
      modalBackdrop.addEventListener("click", e => {
        if (e.target === modalBackdrop) closeModal();
      });
      document.addEventListener("keydown", e => {
        if (modalBackdrop.classList.contains("active")) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeModal();
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
            e.preventDefault();
            undo();
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
            e.preventDefault();
            redo();
          }
        } else {
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
            e.preventDefault();
            undo();
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
            e.preventDefault();
            redo();
          }
        }
      });
      searchInput.addEventListener("input", debounce(e => {
        searchPapers(e.target.value);
      }, 200));
      exportBtn.addEventListener("click", exportPapers);
      themeToggleBtn.addEventListener("click", toggleTheme);
    }

    // Initialize app
    init();
  })();
</script>
</body>
</html>