<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-19T13:31:25.791987Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vocabulary Builder Pro</title>
<style>
  :root {
    --color-bg-light: #f9f9f9;
    --color-text-light: #222;
    --color-bg-dark: #121212;
    --color-text-dark: #eee;
    --color-primary: #007acc;
    --color-primary-dark: #3399ff;
    --color-error: #c0392b;
    --color-success: #27ae60;
    --focus-outline: 2px solid var(--color-primary);
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    font-family: var(--font-family);
    background-color: var(--color-bg-light);
    color: var(--color-text-light);
    line-height: 1.4;
  }
  body.dark {
    background-color: var(--color-bg-dark);
    color: var(--color-text-dark);
  }
  a, button {
    font-family: inherit;
    font-size: 1rem;
    cursor: pointer;
    border: none;
    background: none;
    color: var(--color-primary);
    text-decoration: none;
  }
  a:hover, button:hover, a:focus, button:focus {
    outline: var(--focus-outline);
    color: var(--color-primary-dark);
  }
  button {
    padding: 0.25em 0.5em;
    border-radius: 3px;
    background-color: transparent;
    transition: background-color 0.2s ease;
  }
  button:focus-visible {
    outline-offset: 2px;
  }
  h1, h2, h3 {
    margin: 0.5em 0 0.25em;
  }
  h1 {
    font-size: 1.8rem;
  }
  h2 {
    font-size: 1.4rem;
  }
  h3 {
    font-size: 1.2rem;
  }
  label {
    display: block;
    margin: 0.25em 0 0.1em;
  }
  input[type="text"], input[type="number"], textarea, select {
    width: 100%;
    padding: 0.3em 0.4em;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 1rem;
    box-sizing: border-box;
    background-color: inherit;
    color: inherit;
  }
  input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus {
    outline: var(--focus-outline);
    border-color: var(--color-primary);
  }
  textarea {
    resize: vertical;
  }
  main {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
  }
  @media (min-width: 600px) {
    main {
      grid-template-columns: 1fr 2fr;
    }
  }
  @media (min-width: 900px) {
    main {
      grid-template-columns: 1fr 3fr 2fr;
    }
  }
  nav, section, aside {
    background-color: rgba(0,0,0,0.05);
    padding: 1rem;
    border-radius: 6px;
  }
  body.dark nav, body.dark section, body.dark aside {
    background-color: rgba(255,255,255,0.1);
  }
  nav {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  nav button {
    background-color: var(--color-primary);
    color: white;
    font-weight: 600;
    border-radius: 4px;
  }
  nav button[aria-pressed="true"] {
    background-color: var(--color-primary-dark);
  }
  nav button:focus-visible {
    outline-offset: 2px;
  }
  .word-list {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  body.dark .word-list {
    border-color: #555;
  }
  .word-list table {
    width: 100%;
    border-collapse: collapse;
  }
  .word-list th, .word-list td {
    padding: 0.3em 0.5em;
    border-bottom: 1px solid #ccc;
    text-align: left;
  }
  body.dark .word-list th, body.dark .word-list td {
    border-color: #555;
  }
  .word-list tr:focus-within, .word-list tr:hover {
    background-color: var(--color-primary);
    color: white;
  }
  .word-list tr:focus-within {
    outline: var(--focus-outline);
  }
  .word-list button {
    background-color: transparent;
    color: inherit;
    font-size: 0.9rem;
  }
  .form-group {
    margin-bottom: 0.75rem;
  }
  .form-inline {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
  }
  .form-inline > * {
    flex: 1 1 auto;
  }
  .quiz-area {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .quiz-question {
    font-weight: 600;
    font-size: 1.2rem;
  }
  .quiz-options {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .quiz-options button {
    background-color: var(--color-primary);
    color: white;
    border-radius: 4px;
    padding: 0.5em;
    text-align: left;
  }
  .quiz-options button[aria-pressed="true"] {
    background-color: var(--color-primary-dark);
  }
  .quiz-options button:focus-visible {
    outline-offset: 2px;
  }
  .flashcard {
    border: 2px solid var(--color-primary);
    border-radius: 6px;
    padding: 1rem;
    text-align: center;
    user-select: none;
    cursor: pointer;
  }
  .flashcard .word {
    font-size: 1.5rem;
    font-weight: 700;
  }
  .flashcard .definition, .flashcard .example {
    margin-top: 0.75rem;
    font-style: italic;
  }
  .fill-blank {
    font-size: 1.2rem;
  }
  .fill-blank input[type="text"] {
    font-size: 1.2rem;
    width: auto;
    min-width: 8ch;
    max-width: 20ch;
  }
  .dashboard {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(120px,1fr));
    gap: 1rem;
  }
  .dashboard-item {
    background-color: rgba(0,0,0,0.1);
    border-radius: 6px;
    padding: 0.75rem;
    text-align: center;
  }
  body.dark .dashboard-item {
    background-color: rgba(255,255,255,0.15);
  }
  .dashboard-item strong {
    display: block;
    font-size: 1.3rem;
    margin-bottom: 0.25rem;
  }
  .streak {
    font-size: 1.5rem;
    color: var(--color-success);
  }
  .difficulty-bars {
    display: flex;
    justify-content: center;
    gap: 0.25rem;
  }
  .difficulty-bar {
    width: 20px;
    height: 20px;
    border-radius: 3px;
    background-color: var(--color-primary);
    opacity: 0.3;
  }
  .difficulty-bar.active {
    opacity: 1;
  }
  .import-export textarea {
    width: 100%;
    height: 6em;
    font-family: monospace;
    font-size: 0.9rem;
    background-color: inherit;
    color: inherit;
    border: 1px solid #ccc;
    border-radius: 4px;
    resize: vertical;
  }
  body.dark .import-export textarea {
    border-color: #555;
  }
  .import-export button {
    margin-top: 0.5rem;
    background-color: var(--color-primary);
    color: white;
    border-radius: 4px;
    padding: 0.5em 1em;
  }
  .undo-redo {
    display: flex;
    gap: 0.5rem;
  }
  .undo-redo button {
    background-color: var(--color-primary);
    color: white;
    font-weight: 600;
    border-radius: 4px;
    padding: 0.3em 0.6em;
  }
  .undo-redo button:disabled {
    background-color: #999;
    cursor: default;
  }
  .sr-only {
    position: absolute;
    width: 1px; height: 1px;
    padding: 0; margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    border: 0;
  }
</style>
</head>
<body>
<header>
  <h1>Vocabulary Builder Pro</h1>
  <button id="theme-toggle" aria-pressed="false" aria-label="Toggle dark/light theme">Toggle Dark/Light Theme</button>
</header>
<main>
  <nav aria-label="Main navigation">
    <button id="nav-wordlist" aria-pressed="true" aria-controls="section-wordlist" role="tab" tabindex="0">Word Lists</button>
    <button id="nav-quiz" aria-pressed="false" aria-controls="section-quiz" role="tab" tabindex="-1">Quiz</button>
    <button id="nav-dashboard" aria-pressed="false" aria-controls="section-dashboard" role="tab" tabindex="-1">Dashboard</button>
    <button id="nav-importexport" aria-pressed="false" aria-controls="section-importexport" role="tab" tabindex="-1">Import / Export</button>
  </nav>

  <section id="section-wordlist" role="tabpanel" tabindex="0" aria-labelledby="nav-wordlist" aria-hidden="false">
    <h2>Manage Word Lists</h2>
    <form id="word-form" aria-label="Add or edit word">
      <fieldset>
        <legend>Word Details</legend>
        <div class="form-group">
          <label for="input-word">Word <span aria-hidden="true">*</span></label>
          <input type="text" id="input-word" name="word" required aria-required="true" autocomplete="off" />
        </div>
        <div class="form-group">
          <label for="input-definition">Definition <span aria-hidden="true">*</span></label>
          <textarea id="input-definition" name="definition" rows="2" required aria-required="true"></textarea>
        </div>
        <div class="form-group">
          <label for="input-example">Example Sentence</label>
          <textarea id="input-example" name="example" rows="2" placeholder="Optional example sentence"></textarea>
        </div>
        <div class="form-group">
          <label for="input-difficulty">Difficulty Level (1-5) <span aria-hidden="true">*</span></label>
          <select id="input-difficulty" name="difficulty" required aria-required="true">
            <option value="1">1 - Very Easy</option>
            <option value="2">2 - Easy</option>
            <option value="3" selected>3 - Medium</option>
            <option value="4">4 - Hard</option>
            <option value="5">5 - Very Hard</option>
          </select>
        </div>
        <div class="undo-redo" aria-label="Undo and redo changes">
          <button type="button" id="undo-btn" disabled aria-disabled="true" aria-label="Undo last change">Undo</button>
          <button type="button" id="redo-btn" disabled aria-disabled="true" aria-label="Redo last undone change">Redo</button>
        </div>
        <div class="form-group" style="margin-top:0.5rem;">
          <button type="submit" id="save-word-btn" aria-label="Save word">Save Word</button>
          <button type="button" id="clear-word-btn" aria-label="Clear form">Clear</button>
        </div>
      </fieldset>
    </form>

    <div class="word-list" aria-label="List of vocabulary words" tabindex="0">
      <table role="grid" aria-readonly="true" aria-describedby="wordlist-desc">
        <caption id="wordlist-desc" class="sr-only">Vocabulary words with definition, difficulty, and actions</caption>
        <thead>
          <tr>
            <th scope="col">Word</th>
            <th scope="col">Definition</th>
            <th scope="col">Difficulty</th>
            <th scope="col" aria-label="Actions">Actions</th>
          </tr>
        </thead>
        <tbody id="wordlist-tbody" tabindex="0">
          <!-- Words inserted here -->
        </tbody>
      </table>
    </div>
  </section>

  <section id="section-quiz" role="tabpanel" tabindex="0" aria-labelledby="nav-quiz" aria-hidden="true">
    <h2>Quiz Modes</h2>
    <div class="form-inline" role="group" aria-label="Select quiz mode">
      <label for="quiz-mode-select">Mode:</label>
      <select id="quiz-mode-select" aria-controls="quiz-area" aria-label="Select quiz mode">
        <option value="multiple-choice" selected>Multiple Choice</option>
        <option value="flashcard">Flashcard</option>
        <option value="fill-blank">Fill in the Blank</option>
      </select>
      <button id="quiz-start-btn" aria-label="Start quiz">Start Quiz</button>
      <button id="quiz-stop-btn" aria-label="Stop quiz" disabled>Stop Quiz</button>
    </div>
    <div id="quiz-area" class="quiz-area" aria-live="polite" aria-atomic="true" tabindex="0">
      <!-- Quiz content inserted here -->
    </div>
  </section>

  <section id="section-dashboard" role="tabpanel" tabindex="0" aria-labelledby="nav-dashboard" aria-hidden="true">
    <h2>Progress Dashboard</h2>
    <div class="dashboard" aria-label="User progress statistics">
      <div class="dashboard-item" id="dash-total-words" tabindex="0" aria-live="polite">
        <strong>Total Words</strong>
        <span>0</span>
      </div>
      <div class="dashboard-item" id="dash-mastery" tabindex="0" aria-live="polite">
        <strong>Mastery %</strong>
        <span>0%</span>
      </div>
      <div class="dashboard-item" id="dash-streak" tabindex="0" aria-live="polite">
        <strong>Current Streak</strong>
        <span class="streak">0</span>
      </div>
      <div class="dashboard-item" id="dash-difficulty" tabindex="0" aria-live="polite">
        <strong>Words by Difficulty</strong>
        <div class="difficulty-bars" aria-label="Words count by difficulty levels 1 to 5">
          <div class="difficulty-bar" data-level="1" title="Level 1"></div>
          <div class="difficulty-bar" data-level="2" title="Level 2"></div>
          <div class="difficulty-bar" data-level="3" title="Level 3"></div>
          <div class="difficulty-bar" data-level="4" title="Level 4"></div>
          <div class="difficulty-bar" data-level="5" title="Level 5"></div>
        </div>
      </div>
    </div>
  </section>

  <section id="section-importexport" role="tabpanel" tabindex="0" aria-labelledby="nav-importexport" aria-hidden="true">
    <h2>Import / Export Word Lists</h2>
    <div class="import-export">
      <label for="export-json" id="export-label">Exported JSON</label>
      <textarea id="export-json" aria-labelledby="export-label" readonly rows="8" tabindex="0" aria-live="polite" aria-atomic="true"></textarea>
      <button id="copy-export-btn" aria-label="Copy exported JSON to clipboard">Copy JSON</button>
    </div>
    <div class="import-export" style="margin-top:1rem;">
      <label for="import-json" id="import-label">Paste JSON to Import</label>
      <textarea id="import-json" aria-labelledby="import-label" rows="8" placeholder="Paste JSON here to import word list" aria-multiline="true"></textarea>
      <button id="import-json-btn" aria-label="Import JSON word list">Import JSON</button>
      <div id="import-error" role="alert" style="color: var(--color-error); margin-top: 0.5rem;"></div>
    </div>
  </section>
</main>
<script>
(() => {
  "use strict";

  // Constants
  const STORAGE_KEY = "vocabBuilderProData";
  const THEME_KEY = "vocabBuilderProTheme";
  const MAX_HISTORY = 10;

  // Elements
  const navButtons = {
    wordlist: document.getElementById("nav-wordlist"),
    quiz: document.getElementById("nav-quiz"),
    dashboard: document.getElementById("nav-dashboard"),
    importexport: document.getElementById("nav-importexport"),
  };
  const sections = {
    wordlist: document.getElementById("section-wordlist"),
    quiz: document.getElementById("section-quiz"),
    dashboard: document.getElementById("section-dashboard"),
    importexport: document.getElementById("section-importexport"),
  };
  const themeToggleBtn = document.getElementById("theme-toggle");

  // Word list form inputs
  const form = document.getElementById("word-form");
  const inputWord = document.getElementById("input-word");
  const inputDefinition = document.getElementById("input-definition");
  const inputExample = document.getElementById("input-example");
  const inputDifficulty = document.getElementById("input-difficulty");
  const undoBtn = document.getElementById("undo-btn");
  const redoBtn = document.getElementById("redo-btn");
  const clearWordBtn = document.getElementById("clear-word-btn");
  const saveWordBtn = document.getElementById("save-word-btn");

  // Word list table body
  const wordlistTbody = document.getElementById("wordlist-tbody");

  // Quiz elements
  const quizModeSelect = document.getElementById("quiz-mode-select");
  const quizStartBtn = document.getElementById("quiz-start-btn");
  const quizStopBtn = document.getElementById("quiz-stop-btn");
  const quizArea = document.getElementById("quiz-area");

  // Dashboard elements
  const dashTotalWords = document.getElementById("dash-total-words").querySelector("span");
  const dashMastery = document.getElementById("dash-mastery").querySelector("span");
  const dashStreak = document.getElementById("dash-streak").querySelector(".streak");
  const dashDifficultyBars = document.querySelectorAll(".difficulty-bar");

  // Import/export elements
  const exportJsonTextarea = document.getElementById("export-json");
  const copyExportBtn = document.getElementById("copy-export-btn");
  const importJsonTextarea = document.getElementById("import-json");
  const importJsonBtn = document.getElementById("import-json-btn");
  const importErrorDiv = document.getElementById("import-error");

  // State
  let data = {
    words: [], // array of word objects
    progress: {}, // key: word id, value: progress data
    streak: 0,
    lastCorrectDate: null,
  };
  let history = [];
  let historyIndex = -1;
  let editingWordId = null;
  let quizState = null; // {mode, queue, currentIndex, correctCount, streak, lastAnswerCorrect, lastAnswerDate}
  let theme = "light";

  // Utilities
  function generateId() {
    return "w" + Math.random().toString(36).slice(2, 10);
  }
  function saveData() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }
  function loadData() {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        if (parsed.words && Array.isArray(parsed.words)) {
          data = parsed;
        }
      } catch {}
    }
  }
  function saveTheme() {
    localStorage.setItem(THEME_KEY, theme);
  }
  function loadTheme() {
    const stored = localStorage.getItem(THEME_KEY);
    if (stored === "dark" || stored === "light") {
      theme = stored;
    }
  }
  function applyTheme() {
    if (theme === "dark") {
      document.body.classList.add("dark");
      themeToggleBtn.setAttribute("aria-pressed", "true");
      themeToggleBtn.textContent = "Toggle Light Theme";
    } else {
      document.body.classList.remove("dark");
      themeToggleBtn.setAttribute("aria-pressed", "false");
      themeToggleBtn.textContent = "Toggle Dark Theme";
    }
  }
  function copyToClipboard(text) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(text).catch(() => {});
    }
  }
  function formatDateISO(date) {
    return date.toISOString().slice(0, 10);
  }
  function daysBetween(d1, d2) {
    return Math.floor((d2 - d1) / (1000 * 60 * 60 * 24));
  }
  function clamp(num, min, max) {
    return num < min ? min : num > max ? max : num;
  }
  // Deep clone for history snapshots
  function cloneData(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // History management for undo/redo
  function pushHistory() {
    // Remove redo history if any
    if (historyIndex < history.length - 1) {
      history = history.slice(0, historyIndex + 1);
    }
    history.push(cloneData(data));
    if (history.length > MAX_HISTORY) {
      history.shift();
    } else {
      historyIndex++;
    }
    updateUndoRedoButtons();
  }
  function undo() {
    if (historyIndex > 0) {
      historyIndex--;
      data = cloneData(history[historyIndex]);
      saveData();
      renderWordList();
      renderDashboard();
      if (editingWordId) {
        clearForm();
      }
      updateUndoRedoButtons();
    }
  }
  function redo() {
    if (historyIndex < history.length - 1) {
      historyIndex++;
      data = cloneData(history[historyIndex]);
      saveData();
      renderWordList();
      renderDashboard();
      if (editingWordId) {
        clearForm();
      }
      updateUndoRedoButtons();
    }
  }
  function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    undoBtn.setAttribute("aria-disabled", undoBtn.disabled.toString());
    redoBtn.disabled = historyIndex >= history.length - 1;
    redoBtn.setAttribute("aria-disabled", redoBtn.disabled.toString());
  }

  // Word list management
  function renderWordList() {
    wordlistTbody.innerHTML = "";
    if (data.words.length === 0) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 4;
      td.textContent = "No words added yet.";
      tr.appendChild(td);
      wordlistTbody.appendChild(tr);
      return;
    }
    data.words.forEach((word) => {
      const tr = document.createElement("tr");
      tr.tabIndex = 0;
      tr.setAttribute("role", "row");
      // Word cell
      const tdWord = document.createElement("td");
      tdWord.textContent = word.word;
      tdWord.setAttribute("role", "gridcell");
      tr.appendChild(tdWord);
      // Definition cell
      const tdDef = document.createElement("td");
      tdDef.textContent = word.definition;
      tdDef.setAttribute("role", "gridcell");
      tr.appendChild(tdDef);
      // Difficulty cell
      const tdDiff = document.createElement("td");
      tdDiff.textContent = word.difficulty;
      tdDiff.setAttribute("role", "gridcell");
      tr.appendChild(tdDiff);
      // Actions cell
      const tdActions = document.createElement("td");
      tdActions.setAttribute("role", "gridcell");
      // Edit button
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "Edit";
      editBtn.setAttribute("aria-label", `Edit word ${word.word}`);
      editBtn.addEventListener("click", () => {
        loadWordToForm(word.id);
      });
      tdActions.appendChild(editBtn);
      // Delete button
      const delBtn = document.createElement("button");
      delBtn.type = "button";
      delBtn.textContent = "Delete";
      delBtn.style.marginLeft = "0.5rem";
      delBtn.setAttribute("aria-label", `Delete word ${word.word}`);
      delBtn.addEventListener("click", () => {
        if (confirm(`Delete the word "${word.word}"?`)) {
          deleteWord(word.id);
        }
      });
      tdActions.appendChild(delBtn);
      tr.appendChild(tdActions);
      wordlistTbody.appendChild(tr);
    });
  }
  function loadWordToForm(id) {
    const w = data.words.find((w) => w.id === id);
    if (!w) return;
    editingWordId = id;
    inputWord.value = w.word;
    inputDefinition.value = w.definition;
    inputExample.value = w.example || "";
    inputDifficulty.value = w.difficulty.toString();
    saveWordBtn.textContent = "Update Word";
    inputWord.focus();
  }
  function clearForm() {
    editingWordId = null;
    form.reset();
    saveWordBtn.textContent = "Save Word";
    inputWord.focus();
  }
  function addOrUpdateWord(wordObj) {
    if (editingWordId) {
      // Update existing
      const idx = data.words.findIndex((w) => w.id === editingWordId);
      if (idx !== -1) {
        data.words[idx] = {...wordObj, id: editingWordId};
      }
    } else {
      // Add new
      wordObj.id = generateId();
      data.words.push(wordObj);
    }
    pushHistory();
    saveData();
    renderWordList();
    renderDashboard();
    clearForm();
  }
  function deleteWord(id) {
    const idx = data.words.findIndex((w) => w.id === id);
    if (idx !== -1) {
      data.words.splice(idx, 1);
      // Remove progress for that word
      delete data.progress[id];
      pushHistory();
      saveData();
      renderWordList();
      renderDashboard();
      if (editingWordId === id) clearForm();
    }
  }

  // Spaced repetition algorithm helpers
  // We use a simple algorithm based on last correct answer date and difficulty:
  // Words with no correct answers or older last correct date appear more frequently.
  // Difficulty affects interval length: harder words reviewed more often.
  // We calculate a "due score" for each word; higher means more due.
  function getDueWords() {
    const now = new Date();
    return data.words
      .map((word) => {
        const prog = data.progress[word.id];
        let lastCorrect = prog && prog.lastCorrect ? new Date(prog.lastCorrect) : null;
        let intervalDays = 1;
        if (prog && prog.correctCount > 0) {
          // Base interval grows exponentially with correctCount and difficulty
          intervalDays = Math.min(60, Math.pow(2, prog.correctCount) * (6 - word.difficulty));
        }
        let daysSince = lastCorrect ? daysBetween(lastCorrect, now) : 1000;
        // Due score: how overdue the word is (daysSince - intervalDays), minimum 0
        let dueScore = Math.max(0, daysSince - intervalDays);
        // Boost dueScore by difficulty (harder words get higher priority)
        dueScore *= word.difficulty;
        return {word, dueScore};
      })
      .filter(({dueScore}) => dueScore > 0)
      .sort((a, b) => b.dueScore - a.dueScore)
      .map(({word}) => word);
  }

  // Quiz logic
  function startQuiz() {
    if (data.words.length === 0) {
      alert("Add some words first to start the quiz.");
      return;
    }
    quizState = {
      mode: quizModeSelect.value,
      queue: [],
      currentIndex: 0,
      correctCount: 0,
      streak: 0,
      lastAnswerCorrect: null,
      lastAnswerDate: null,
    };
    // Build queue based on spaced repetition due words and fill with others if needed
    const dueWords = getDueWords();
    let queue = [];
    if (dueWords.length >= 20) {
      queue = dueWords.slice(0, 20);
    } else {
      queue = dueWords.slice();
      // Fill with random words not in dueWords until 20 or all words included
      const notDue = data.words.filter(w => !queue.includes(w));
      while (queue.length < 20 && notDue.length > 0) {
        const idx = Math.floor(Math.random() * notDue.length);
        queue.push(notDue.splice(idx, 1));
      }
    }
    // Shuffle queue
    for (let i = queue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [queue[i], queue[j]] = [queue[j], queue[i]];
    }
    quizState.queue = queue;
    quizState.currentIndex = 0;
    quizState.correctCount = 0;
    quizState.streak = 0;
    quizState.lastAnswerCorrect = null;
    quizState.lastAnswerDate = null;

    quizStartBtn.disabled = true;
    quizStopBtn.disabled = false;
    quizModeSelect.disabled = true;
    renderQuizQuestion();
  }
  function stopQuiz() {
    quizState = null;
    quizArea.innerHTML = "";
    quizStartBtn.disabled = false;
    quizStopBtn.disabled = true;
    quizModeSelect.disabled = false;
  }
  function renderQuizQuestion() {
    if (!quizState) return;
    if (quizState.currentIndex >= quizState.queue.length) {
      // Quiz finished
      quizArea.innerHTML = `<p>Quiz complete! You answered correctly ${quizState.correctCount} out of ${quizState.queue.length}.</p>`;
      stopQuiz();
      renderDashboard();
      return;
    }
    const word = quizState.queue[quizState.currentIndex];
    quizArea.innerHTML = "";
    if (quizState.mode === "multiple-choice") {
      renderMultipleChoice(word);
    } else if (quizState.mode === "flashcard") {
      renderFlashcard(word);
    } else if (quizState.mode === "fill-blank") {
      renderFillBlank(word);
    }
  }
  function renderMultipleChoice(word) {
    const question = document.createElement("div");
    question.className = "quiz-question";
    question.textContent = `What is the definition of "${word.word}"?`;
    quizArea.appendChild(question);

    const optionsDiv = document.createElement("div");
    optionsDiv.className = "quiz-options";
    optionsDiv.setAttribute("role", "list");
    // Prepare 4 options: correct + 3 random definitions
    const correctDef = word.definition;
    let options = [correctDef];
    // Gather other definitions for distractors
    const otherDefs = data.words
      .filter(w => w.id !== word.id)
      .map(w => w.definition);
    // Shuffle and pick 3 distractors
    for (let i = otherDefs.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [otherDefs[i], otherDefs[j]] = [otherDefs[j], otherDefs[i]];
    }
    options = options.concat(otherDefs.slice(0, 3));
    // Shuffle options
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }
    // Create buttons for options
    options.forEach((opt, i) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.textContent = opt;
      btn.setAttribute("role", "listitem");
      btn.setAttribute("aria-label", `Option ${i + 1}`);
      btn.addEventListener("click", () => {
        handleQuizAnswer(word, opt === correctDef);
      });
      optionsDiv.appendChild(btn);
    });
    quizArea.appendChild(optionsDiv);
    // Focus first option
    optionsDiv.querySelector("button")?.focus();
  }
  function renderFlashcard(word) {
    const card = document.createElement("div");
    card.className = "flashcard";
    card.tabIndex = 0;
    card.setAttribute("role", "button");
    card.setAttribute("aria-pressed", "false");
    card.setAttribute("aria-label", `Flashcard for word ${word.word}. Press Enter or Space to reveal definition.`);
    const wordDiv = document.createElement("div");
    wordDiv.className = "word";
    wordDiv.textContent = word.word;
    card.appendChild(wordDiv);
    const defDiv = document.createElement("div");
    defDiv.className = "definition";
    defDiv.style.display = "none";
    defDiv.textContent = word.definition;
    card.appendChild(defDiv);
    if (word.example) {
      const exDiv = document.createElement("div");
      exDiv.className = "example";
      exDiv.style.display = "none";
      exDiv.textContent = `"${word.example}"`;
      card.appendChild(exDiv);
    }
    const btnsDiv = document.createElement("div");
    btnsDiv.style.marginTop = "1rem";
    btnsDiv.style.display = "flex";
    btnsDiv.style.justifyContent = "center";
    btnsDiv.style.gap = "1rem";

    const correctBtn = document.createElement("button");
    correctBtn.type = "button";
    correctBtn.textContent = "I Knew It";
    correctBtn.disabled = true;
    correctBtn.setAttribute("aria-label", "Mark as known");
    btnsDiv.appendChild(correctBtn);

    const wrongBtn = document.createElement("button");
    wrongBtn.type = "button";
    wrongBtn.textContent = "I Didn't Know";
    wrongBtn.disabled = true;
    wrongBtn.setAttribute("aria-label", "Mark as unknown");
    btnsDiv.appendChild(wrongBtn);

    card.appendChild(btnsDiv);

    let revealed = false;
    function toggleReveal() {
      revealed = !revealed;
      defDiv.style.display = revealed ? "block" : "none";
      if (defDiv.nextSibling) defDiv.nextSibling.style.display = revealed && word.example ? "block" : "none";
      card.setAttribute("aria-pressed", revealed.toString());
      correctBtn.disabled = !revealed;
      wrongBtn.disabled = !revealed;
      if (revealed) {
        correctBtn.focus();
      } else {
        card.focus();
      }
    }
    card.addEventListener("click", toggleReveal);
    card.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
        e.preventDefault();
        toggleReveal();
      }
    });
    correctBtn.addEventListener("click", () => {
      handleQuizAnswer(word, true);
    });
    wrongBtn.addEventListener("click", () => {
      handleQuizAnswer(word, false);
    });
    quizArea.appendChild(card);
    card.focus();
  }
  function renderFillBlank(word) {
    const sentence = word.example || `The word is: ${word.word}`;
    // Replace the word in example sentence with blank if possible
    let questionText = sentence;
    const regex = new RegExp(`\\b${word.word}\\b`, "i");
    if (regex.test(sentence)) {
      questionText = sentence.replace(regex, "_____");
    } else {
      questionText = `Fill in the blank: ${sentence}`;
    }
    const question = document.createElement("div");
    question.className = "quiz-question fill-blank";
    question.textContent = questionText;
    quizArea.appendChild(question);

    const input = document.createElement("input");
    input.type = "text";
    input.setAttribute("aria-label", `Fill in the blank for word ${word.word}`);
    input.autocomplete = "off";
    input.spellcheck = false;
    quizArea.appendChild(input);

    const submitBtn = document.createElement("button");
    submitBtn.type = "button";
    submitBtn.textContent = "Submit";
    submitBtn.setAttribute("aria-label", "Submit answer");
    quizArea.appendChild(submitBtn);

    const feedback = document.createElement("div");
    feedback.setAttribute("aria-live", "polite");
    feedback.style.marginTop = "0.5rem";
    quizArea.appendChild(feedback);

    function checkAnswer() {
      const answer = input.value.trim().toLowerCase();
      const correct = answer === word.word.toLowerCase();
      feedback.textContent = correct ? "Correct!" : `Incorrect. The correct word is "${word.word}".`;
      submitBtn.disabled = true;
      input.disabled = true;
      handleQuizAnswer(word, correct);
    }
    submitBtn.addEventListener("click", checkAnswer);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        if (!submitBtn.disabled) checkAnswer();
      }
    });
    input.focus();
  }
  function handleQuizAnswer(word, correct) {
    // Update progress for word
    const now = new Date();
    if (!data.progress[word.id]) {
      data.progress[word.id] = {
        correctCount: 0,
        totalCount: 0,
        lastCorrect: null,
        lastAttempt: null,
        retention: 0,
      };
    }
    const prog = data.progress[word.id];
    prog.totalCount++;
    if (correct) {
      prog.correctCount++;
      prog.lastCorrect = now.toISOString();
      quizState.correctCount++;
      quizState.streak++;
      data.streak = Math.max(data.streak, quizState.streak);
    } else {
      quizState.streak = 0;
    }
    prog.lastAttempt = now.toISOString();
    prog.retention = Math.round((prog.correctCount / prog.totalCount) * 100);
    data.lastCorrectDate = correct ? now.toISOString() : data.lastCorrectDate;
    saveData();
    renderDashboard();
    quizState.currentIndex++;
    setTimeout(renderQuizQuestion, 800);
  }

  // Dashboard rendering
  function renderDashboard() {
    const totalWords = data.words.length;
    dashTotalWords.textContent = totalWords.toString();
    if (totalWords === 0) {
      dashMastery.textContent = "0%";
      dashStreak.textContent = "0";
      dashDifficultyBars.forEach((bar) => {
        bar.style.opacity = "0.3";
        bar.textContent = "";
      });
      return;
    }
    // Mastery % = average retention % of all words
    let totalRetention = 0;
    data.words.forEach((w) => {
      const prog = data.progress[w.id];
      totalRetention += prog ? prog.retention : 0;
    });
    const mastery = Math.round(totalRetention / totalWords);
    dashMastery.textContent = mastery + "%";
    dashStreak.textContent = data.streak.toString();

    // Words by difficulty count
    const counts = [0, 0, 0, 0, 0];
    data.words.forEach((w) => {
      const d = clamp(w.difficulty, 1, 5);
      counts[d - 1]++;
    });
    const maxCount = Math.max(...counts, 1);
    dashDifficultyBars.forEach((bar, i) => {
      const count = counts[i];
      bar.style.opacity = count === 0 ? "0.3" : "1";
      bar.textContent = count > 0 ? count : "";
    });
  }

  // Import/export
  function exportData() {
    const exportObj = {
      words: data.words,
      progress: data.progress,
      streak: data.streak,
      lastCorrectDate: data.lastCorrectDate,
    };
    const jsonStr = JSON.stringify(exportObj, null, 2);
    exportJsonTextarea.value = jsonStr;
  }
  function importData(jsonStr) {
    try {
      const imported = JSON.parse(jsonStr);
      if (!imported.words || !Array.isArray(imported.words)) {
        throw new Error("Invalid JSON: missing words array.");
      }
      // Validate words array entries minimally
      for (const w of imported.words) {
        if (typeof w.word !== "string" || typeof w.definition !== "string" || typeof w.difficulty !== "number") {
          throw new Error("Invalid word entry in JSON.");
        }
      }
      data.words = imported.words.map(w => ({
        id: w.id || generateId(),
        word: w.word,
        definition: w.definition,
        example: w.example || "",
        difficulty: clamp(w.difficulty, 1, 5),
      }));
      data.progress = imported.progress || {};
      data.streak = imported.streak || 0;
      data.lastCorrectDate = imported.lastCorrectDate || null;
      pushHistory();
      saveData();
      renderWordList();
      renderDashboard();
      importErrorDiv.textContent = "";
      alert("Import successful.");
    } catch (e) {
      importErrorDiv.textContent = "Import failed: " + e.message;
    }
  }

  // Navigation and tab management
  function switchTab(to) {
    for (const key in navButtons) {
      const btn = navButtons[key];
      const sec = sections[key];
      if (key === to) {
        btn.setAttribute("aria-pressed", "true");
        btn.tabIndex = 0;
        sec.removeAttribute("aria-hidden");
        sec.tabIndex = 0;
      } else {
        btn.setAttribute("aria-pressed", "false");
        btn.tabIndex = -1;
        sec.setAttribute("aria-hidden", "true");
        sec.tabIndex = -1;
      }
    }
    // Focus first focusable element in section
    const focusable = sections[to].querySelector("button, [tabindex='0'], input, select, textarea");
    if (focusable) focusable.focus();
  }

  // Event listeners
  themeToggleBtn.addEventListener("click", () => {
    theme = theme === "dark" ? "light" : "dark";
    applyTheme();
    saveTheme();
  });

  Object.entries(navButtons).forEach(([key, btn]) => {
    btn.addEventListener("click", () => {
      switchTab(key);
    });
    btn.addEventListener("keydown", (e) => {
      if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        e.preventDefault();
        const keys = Object.keys(navButtons);
        let idx = keys.indexOf(key);
        idx = (idx + 1) % keys.length;
        navButtons[keys[idx]].focus();
      } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        e.preventDefault();
        const keys = Object.keys(navButtons);
        let idx = keys.indexOf(key);
        idx = (idx - 1 + keys.length) % keys.length;
        navButtons[keys[idx]].focus();
      } else if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
        e.preventDefault();
        switchTab(key);
      }
    });
  });

  form.addEventListener("submit", (e) => {
    e.preventDefault();
    const wordVal = inputWord.value.trim();
    const defVal = inputDefinition.value.trim();
    const exVal = inputExample.value.trim();
    const diffVal = parseInt(inputDifficulty.value, 10);
    if (!wordVal || !defVal || isNaN(diffVal) || diffVal < 1 || diffVal > 5) {
      alert("Please fill in all required fields correctly.");
      return;
    }
    addOrUpdateWord({
      word: wordVal,
      definition: defVal,
      example: exVal,
      difficulty: diffVal,
    });
  });
  clearWordBtn.addEventListener("click", () => {
    clearForm();
  });
  undoBtn.addEventListener("click", () => {
    undo();
  });
  redoBtn.addEventListener("click", () => {
    redo();
  });

  quizStartBtn.addEventListener("click", () => {
    startQuiz();
  });
  quizStopBtn.addEventListener("click", () => {
    stopQuiz();
  });

  copyExportBtn.addEventListener("click", () => {
    copyToClipboard(exportJsonTextarea.value);
  });
  importJsonBtn.addEventListener("click", () => {
    importData(importJsonTextarea.value.trim());
  });

  // Keyboard navigation for quiz options (multiple choice)
  quizArea.addEventListener("keydown", (e) => {
    if (!quizState || quizState.mode !== "multiple-choice") return;
    const options = quizArea.querySelectorAll(".quiz-options button");
    if (options.length === 0) return;
    let idx = Array.prototype.indexOf.call(options, document.activeElement);
    if (idx === -1) return;
    if (e.key === "ArrowDown" || e.key === "ArrowRight") {
      e.preventDefault();
      idx = (idx + 1) % options.length;
      options[idx].focus();
    } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
      e.preventDefault();
      idx = (idx - 1 + options.length) % options.length;
      options[idx].focus();
    }
  });

  // Initialization
  function init() {
    loadData();
    loadTheme();
    applyTheme();
    pushHistory(); // initial state
    renderWordList();
    renderDashboard();
    exportData();
    switchTab("wordlist");
  }
  init();
  // Update export JSON on data changes
  const origSaveData = saveData;
  saveData = function() {
    origSaveData();
    exportData();
  };
})();  
</script>
</body>
</html>