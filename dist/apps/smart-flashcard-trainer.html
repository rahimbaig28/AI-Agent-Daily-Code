<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-12-06T04:21:47.390595Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Smart Flashcard Trainer CLI</title>
<style>
  body {
    font-family: monospace, monospace;
    background: #f9f9f9;
    color: #222;
    margin: 0; padding: 1em;
  }
  h1 {
    font-weight: normal;
    font-size: 1.5em;
    margin-bottom: 0.5em;
  }
  #output {
    white-space: pre-wrap;
    background: #fff;
    border: 1px solid #ccc;
    padding: 0.8em;
    height: 300px;
    overflow-y: auto;
    margin-bottom: 0.5em;
  }
  #input-area {
    display: flex;
    gap: 0.5em;
  }
  label {
    flex-shrink: 0;
  }
  input[type="text"] {
    flex-grow: 1;
    font-family: monospace, monospace;
    font-size: 1em;
    padding: 0.3em 0.4em;
    border: 1px solid #aaa;
    border-radius: 3px;
  }
  button {
    font-family: monospace, monospace;
    font-size: 1em;
    padding: 0.3em 0.6em;
    cursor: pointer;
    border: 1px solid #444;
    border-radius: 3px;
    background: #eee;
  }
  button:focus, input[type="text"]:focus {
    outline: 2px solid #007acc;
  }
  #help {
    font-size: 0.9em;
    color: #555;
    margin-top: 0.5em;
    max-height: 10em;
    overflow-y: auto;
    background: #f0f0f0;
    padding: 0.5em;
    border-radius: 3px;
  }
  @media (max-width: 480px) {
    #input-area {
      flex-direction: column;
    }
    button {
      width: 100%;
    }
  }
</style>
</head>
<body>
<h1>Smart Flashcard Trainer CLI</h1>
<div id="output" role="log" aria-live="polite" tabindex="0"></div>
<div id="input-area">
  <label for="command-input" id="cmd-label">Command:</label>
  <input type="text" id="command-input" aria-labelledby="cmd-label" autocomplete="off" />
  <button id="submit-btn" aria-label="Submit command">Enter</button>
</div>
<div id="help" aria-live="polite" hidden></div>
<script>
(() => {
  "use strict";

  // Persistent storage key and default deck filename
  const STORAGE_KEY = "smart_flashcard_trainer_data";
  const DEFAULT_DECK_FILENAME = "default_deck.json";

  // Elements
  const outputEl = document.getElementById("output");
  const inputEl = document.getElementById("command-input");
  const submitBtn = document.getElementById("submit-btn");
  const helpEl = document.getElementById("help");

  // State
  let decks = {}; // { deckName: { flashcards: [...], studyProgress: {...} } }
  let currentDeckName = DEFAULT_DECK_FILENAME;
  let undoStack = [];
  let redoStack = [];
  let studySession = null; // { indices: [], currentIndex: number, knownSet: Set, unknownSet: Set }

  // Utility functions
  function saveData() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ decks, currentDeckName }));
    } catch (e) {
      appendOutput("Error saving data: " + e.message);
    }
  }

  function loadData() {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (data) {
        const parsed = JSON.parse(data);
        if (parsed.decks && typeof parsed.currentDeckName === "string") {
          decks = parsed.decks;
          currentDeckName = parsed.currentDeckName;
          if (!decks[currentDeckName]) {
            decks[currentDeckName] = { flashcards: [], studyProgress: {} };
          }
          return;
        }
      }
    } catch (e) {
      appendOutput("Error loading data: " + e.message);
    }
    // Initialize default deck if none loaded
    decks = {};
    decks[DEFAULT_DECK_FILENAME] = { flashcards: [], studyProgress: {} };
    currentDeckName = DEFAULT_DECK_FILENAME;
  }

  function appendOutput(text) {
    outputEl.textContent += text + "\n";
    outputEl.scrollTop = outputEl.scrollHeight;
  }

  function clearOutput() {
    outputEl.textContent = "";
  }

  function promptInput(promptText) {
    appendOutput(promptText);
  }

  function randomInt(max) {
    return Math.floor(Math.random() * max);
  }

  function cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // Deck and flashcard management
  function getCurrentDeck() {
    if (!decks[currentDeckName]) {
      decks[currentDeckName] = { flashcards: [], studyProgress: {} };
    }
    return decks[currentDeckName];
  }

  function addFlashcard(question, answer) {
    const deck = getCurrentDeck();
    deck.flashcards.push({ question, answer, known: false });
    saveData();
  }

  function deleteFlashcard(index) {
    const deck = getCurrentDeck();
    if (index < 0 || index >= deck.flashcards.length) {
      return false;
    }
    deck.flashcards.splice(index, 1);
    saveData();
    return true;
  }

  function listFlashcards() {
    const deck = getCurrentDeck();
    if (deck.flashcards.length === 0) {
      appendOutput("No flashcards in current deck.");
      return;
    }
    deck.flashcards.forEach((fc, i) => {
      appendOutput(`${i + 1}. Q: ${fc.question}\n   A: ${fc.answer}\n   Known: ${fc.known ? "Yes" : "No"}`);
    });
  }

  // Undo/Redo management
  function pushUndo(action) {
    undoStack.push(action);
    if (undoStack.length > 100) undoStack.shift();
    redoStack = [];
  }

  function undo() {
    if (undoStack.length === 0) {
      appendOutput("Nothing to undo.");
      return;
    }
    const action = undoStack.pop();
    redoStack.push(cloneDeep({ decks, currentDeckName, studySession }));
    restoreState(action);
    appendOutput("Undo performed.");
  }

  function redo() {
    if (redoStack.length === 0) {
      appendOutput("Nothing to redo.");
      return;
    }
    const action = redoStack.pop();
    undoStack.push(cloneDeep({ decks, currentDeckName, studySession }));
    restoreState(action);
    appendOutput("Redo performed.");
  }

  function restoreState(state) {
    decks = cloneDeep(state.decks);
    currentDeckName = state.currentDeckName;
    studySession = state.studySession ? cloneDeep(state.studySession) : null;
    saveData();
  }

  // Study mode
  function startStudy() {
    const deck = getCurrentDeck();
    if (deck.flashcards.length === 0) {
      appendOutput("No flashcards to study in current deck.");
      return;
    }
    studySession = {
      indices: [...Array(deck.flashcards.length).keys()],
      currentIndex: 0,
      knownSet: new Set(),
      unknownSet: new Set(),
      revealed: false
    };
    shuffleArray(studySession.indices);
    appendOutput("Study mode started. Type 'next' to see the first question.");
  }

  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = randomInt(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function studyNext() {
    if (!studySession) {
      appendOutput("Study mode is not active. Use 'study' command to start.");
      return;
    }
    const deck = getCurrentDeck();
    if (studySession.currentIndex >= studySession.indices.length) {
      appendOutput("Study session complete.");
      studySession = null;
      return;
    }
    const idx = studySession.indices[studySession.currentIndex];
    const card = deck.flashcards[idx];
    appendOutput(`Q: ${card.question}`);
    studySession.revealed = false;
  }

  function revealAnswer() {
    if (!studySession) {
      appendOutput("Study mode is not active.");
      return;
    }
    if (studySession.currentIndex >= studySession.indices.length) {
      appendOutput("No current card to reveal.");
      return;
    }
    if (studySession.revealed) {
      appendOutput("Answer already revealed. Use 'known' or 'unknown' to mark.");
      return;
    }
    const deck = getCurrentDeck();
    const idx = studySession.indices[studySession.currentIndex];
    const card = deck.flashcards[idx];
    appendOutput(`A: ${card.answer}`);
    studySession.revealed = true;
  }

  function markKnown(isKnown) {
    if (!studySession) {
      appendOutput("Study mode is not active.");
      return;
    }
    if (studySession.currentIndex >= studySession.indices.length) {
      appendOutput("No current card to mark.");
      return;
    }
    if (!studySession.revealed) {
      appendOutput("Reveal the answer first with 'show' command.");
      return;
    }
    const deck = getCurrentDeck();
    const idx = studySession.indices[studySession.currentIndex];
    deck.flashcards[idx].known = isKnown;
    if (isKnown) {
      studySession.knownSet.add(idx);
      studySession.unknownSet.delete(idx);
    } else {
      studySession.unknownSet.add(idx);
      studySession.knownSet.delete(idx);
    }
    pushUndo(cloneDeep({ decks, currentDeckName, studySession }));
    studySession.currentIndex++;
    studySession.revealed = false;
    appendOutput(isKnown ? "Marked as known." : "Marked as unknown.");
    if (studySession.currentIndex < studySession.indices.length) {
      appendOutput("Type 'next' for next question.");
    } else {
      appendOutput("Study session complete.");
      studySession = null;
    }
    saveData();
  }

  // Import/export JSON
  function importDeck(jsonText) {
    try {
      const imported = JSON.parse(jsonText);
      if (!Array.isArray(imported)) {
        appendOutput("Import failed: JSON must be an array of flashcards.");
        return;
      }
      const deck = getCurrentDeck();
      let added = 0;
      imported.forEach(fc => {
        if (fc.question && fc.answer) {
          deck.flashcards.push({ question: fc.question, answer: fc.answer, known: false });
          added++;
        }
      });
      saveData();
      appendOutput(`Imported ${added} flashcards.`);
      pushUndo(cloneDeep({ decks, currentDeckName, studySession }));
    } catch (e) {
      appendOutput("Import failed: Invalid JSON.");
    }
  }

  function exportDeck() {
    const deck = getCurrentDeck();
    const exportData = deck.flashcards.map(fc => ({ question: fc.question, answer: fc.answer }));
    return JSON.stringify(exportData, null, 2);
  }

  // Search flashcards
  function searchFlashcards(keyword) {
    const deck = getCurrentDeck();
    const results = deck.flashcards
      .map((fc, i) => ({ index: i, flashcard: fc }))
      .filter(({ flashcard }) =>
        flashcard.question.toLowerCase().includes(keyword.toLowerCase()) ||
        flashcard.answer.toLowerCase().includes(keyword.toLowerCase())
      );
    if (results.length === 0) {
      appendOutput(`No flashcards found matching "${keyword}".`);
      return;
    }
    results.forEach(({ index, flashcard }) => {
      appendOutput(`${index + 1}. Q: ${flashcard.question}\n   A: ${flashcard.answer}\n   Known: ${flashcard.known ? "Yes" : "No"}`);
    });
  }

  // Command processing
  function showHelp() {
    helpEl.hidden = false;
    helpEl.textContent = `
Commands:
  help                 Show this help message
  add                  Add a new flashcard (prompts for Q and A)
  list                 List all flashcards in current deck
  study                Start study mode (random quiz)
  next                 Show next question in study mode
  show                 Reveal answer to current question in study mode
  known                Mark current flashcard as known (in study mode)
  unknown              Mark current flashcard as unknown (in study mode)
  delete <num>         Delete flashcard by number (from list)
  undo                 Undo last add/delete/study mark action
  redo                 Redo last undone action
  import               Import flashcards from JSON (paste JSON after prompt)
  export               Export current deck flashcards as JSON
  search <keyword>     Search flashcards by keyword in Q or A
  deck <name>          Switch to or create deck with given name
  decks                List all deck names
  quit                 Exit the program
`;
  }

  function hideHelp() {
    helpEl.hidden = true;
  }

  // Input handler state for multi-step commands
  let multiStep = null;

  function handleMultiStepInput(line) {
    if (!multiStep) return false;
    if (multiStep.type === "add_question") {
      multiStep.question = line.trim();
      appendOutput("Enter answer:");
      multiStep.type = "add_answer";
      return true;
    }
    if (multiStep.type === "add_answer") {
      multiStep.answer = line.trim();
      if (!multiStep.question || !multiStep.answer) {
        appendOutput("Question and answer cannot be empty. Aborting add.");
        multiStep = null;
        return true;
      }
      pushUndo(cloneDeep({ decks, currentDeckName, studySession }));
      addFlashcard(multiStep.question, multiStep.answer);
      appendOutput("Flashcard added.");
      multiStep = null;
      return true;
    }
    if (multiStep.type === "import_json") {
      const jsonText = line.trim();
      importDeck(jsonText);
      multiStep = null;
      return true;
    }
    return false;
  }

  function processCommand(line) {
    if (handleMultiStepInput(line)) return;

    const args = line.trim().split(/\s+/);
    const cmd = args?.toLowerCase();

    switch (cmd) {
      case "help":
        showHelp();
        break;

      case "add":
        appendOutput("Enter question:");
        multiStep = { type: "add_question" };
        break;

      case "list":
        listFlashcards();
        break;

      case "study":
        startStudy();
        break;

      case "next":
        studyNext();
        break;

      case "show":
        revealAnswer();
        break;

      case "known":
        markKnown(true);
        break;

      case "unknown":
        markKnown(false);
        break;

      case "delete":
        if (args.length < 2) {
          appendOutput("Usage: delete <flashcard_number>");
          break;
        }
        const delIndex = parseInt(args[1], 10) - 1;
        if (isNaN(delIndex)) {
          appendOutput("Invalid flashcard number.");
          break;
        }
        const deck = getCurrentDeck();
        if (delIndex < 0 || delIndex >= deck.flashcards.length) {
          appendOutput("Flashcard number out of range.");
          break;
        }
        pushUndo(cloneDeep({ decks, currentDeckName, studySession }));
        deck.flashcards.splice(delIndex, 1);
        saveData();
        appendOutput(`Deleted flashcard #${delIndex + 1}.`);
        break;

      case "undo":
        undo();
        break;

      case "redo":
        redo();
        break;

      case "import":
        appendOutput("Paste JSON array of flashcards (each with 'question' and 'answer'), then press Enter:");
        multiStep = { type: "import_json" };
        break;

      case "export":
        const jsonExport = exportDeck();
        appendOutput("Exported JSON:\n" + jsonExport);
        break;

      case "search":
        if (args.length < 2) {
          appendOutput("Usage: search <keyword>");
          break;
        }
        const keyword = args.slice(1).join(" ");
        searchFlashcards(keyword);
        break;

      case "deck":
        if (args.length < 2) {
          appendOutput(`Current deck: ${currentDeckName}`);
          break;
        }
        const newDeckName = args.slice(1).join(" ");
        if (!decks[newDeckName]) {
          decks[newDeckName] = { flashcards: [], studyProgress: {} };
          appendOutput(`Created new deck: ${newDeckName}`);
        } else {
          appendOutput(`Switched to deck: ${newDeckName}`);
        }
        currentDeckName = newDeckName;
        saveData();
        break;

      case "decks":
        const deckNames = Object.keys(decks);
        if (deckNames.length === 0) {
          appendOutput("No decks available.");
        } else {
          appendOutput("Decks:");
          deckNames.forEach(dn => {
            appendOutput(` - ${dn}${dn === currentDeckName ? " (current)" : ""}`);
          });
        }
        break;

      case "quit":
      case "exit":
        appendOutput("Exiting... Thank you for using Smart Flashcard Trainer.");
        inputEl.disabled = true;
        submitBtn.disabled = true;
        break;

      case "":
        // ignore empty input
        break;

      default:
        appendOutput(`Unknown command: "${cmd}". Type "help" for list of commands.`);
        break;
    }
  }

  // Event handlers
  submitBtn.addEventListener("click", () => {
    const line = inputEl.value;
    inputEl.value = "";
    processCommand(line);
    inputEl.focus();
  });

  inputEl.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      submitBtn.click();
    }
  });

  // Initialization
  function init() {
    loadData();
    appendOutput("Welcome to Smart Flashcard Trainer CLI.");
    appendOutput(`Current deck: ${currentDeckName}`);
    appendOutput('Type "help" for commands.');
    inputEl.focus();
  }

  init();
})();
</script>
</body>
</html>