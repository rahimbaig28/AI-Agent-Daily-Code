<!DOCTYPE html>
<html lang="en">
<head>
<!-- Auto-generated via Perplexity on 2025-11-28T13:28:14.807762Z -->

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Accessible Clipboard Helper</title>
<style>
  :root {
    --bg-light: #f9f9f9;
    --fg-light: #222;
    --bg-dark: #121212;
    --fg-dark: #eee;
    --accent: #007acc;
    --error: #d9534f;
    --warning: #f0ad4e;
    --success: #5cb85c;
    --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  body {
    margin: 0; padding: 1rem; font-family: var(--font-family);
    background-color: var(--bg-light);
    color: var(--fg-light);
    min-height: 100vh;
    display: flex; flex-direction: column; align-items: center;
  }
  body.dark {
    background-color: var(--bg-dark);
    color: var(--fg-dark);
  }
  h1 {
    margin-bottom: 0.25rem;
  }
  #app {
    max-width: 600px;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 1rem 1.5rem;
    box-sizing: border-box;
    background: inherit;
    color: inherit;
  }
  button, select, input[type="text"], textarea {
    font-family: var(--font-family);
    font-size: 1rem;
    margin: 0.25rem 0;
  }
  button {
    background-color: var(--accent);
    border: none;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
  }
  button:focus {
    outline: 3px solid #005a9e;
    outline-offset: 2px;
  }
  button:disabled {
    background-color: #999;
    cursor: not-allowed;
  }
  label {
    display: block;
    margin-top: 1rem;
    font-weight: 600;
  }
  textarea {
    width: 100%;
    height: 6rem;
    resize: vertical;
  }
  select {
    width: 100%;
    padding: 0.3rem;
  }
  #menu {
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
  }
  #menu button {
    margin: 0.3rem 0;
  }
  #output {
    margin-top: 1rem;
    white-space: pre-wrap;
    background: rgba(0,0,0,0.05);
    padding: 0.5rem;
    border-radius: 4px;
    max-height: 200px;
    overflow-y: auto;
  }
  #message {
    margin-top: 1rem;
    font-weight: 600;
  }
  #message.error {
    color: var(--error);
  }
  #message.success {
    color: var(--success);
  }
  #message.warning {
    color: var(--warning);
  }
  @media (prefers-color-scheme: dark) {
    body:not(.light) {
      background-color: var(--bg-dark);
      color: var(--fg-dark);
    }
  }
</style>
</head>
<body>
<div id="app" role="main" aria-label="Accessible Clipboard Helper">
  <h1>Accessible Clipboard Helper</h1>
  <p>Manage named text snippets with clipboard integration and JSON import/export.</p>

  <div id="menu" role="menu" aria-label="Main menu">
    <button id="addClipboardBtn" role="menuitem" aria-haspopup="dialog">Add Snippet from Clipboard</button>
    <button id="addInputBtn" role="menuitem" aria-haspopup="dialog">Add Snippet from Typed Input</button>
    <button id="listBtn" role="menuitem">List Snippets</button>
    <button id="retrieveBtn" role="menuitem" aria-haspopup="dialog">Retrieve Snippet</button>
    <button id="deleteBtn" role="menuitem" aria-haspopup="dialog">Delete Snippet</button>
    <button id="exportBtn" role="menuitem" aria-haspopup="dialog">Export Snippets</button>
    <button id="importBtn" role="menuitem" aria-haspopup="dialog">Import Snippets</button>
  </div>

  <div id="dialogContainer" aria-live="polite"></div>

  <div id="output" aria-live="polite" aria-atomic="true" tabindex="0"></div>
  <div id="message" role="alert" aria-live="assertive"></div>
</div>

<script>
(() => {
  const snippetsKey = 'accessibleClipboardHelperSnippets';
  const homeDir = (() => {
    if (typeof navigator !== 'undefined' && navigator.userAgent) {
      // Browser environment fallback (not expected here)
      return null;
    }
    try {
      return (typeof process !== 'undefined' && process.env && (process.env.HOME || process.env.USERPROFILE)) || null;
    } catch {
      return null;
    }
  })();

  // Detect terminal color support simulation for theme toggle (in browser, use prefers-color-scheme)
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  if (prefersDark) document.body.classList.add('dark');

  // Clipboard interaction via standard library subprocess emulation:
  // Here we simulate clipboard with navigator.clipboard if available, else fallback to prompt instructions.
  // Since no external libs allowed and no subprocess in browser, we simulate clipboard for demo.
  // In actual CLI Python script, subprocess calls to clip/pbcopy/xclip would be used.

  // For the purpose of this standalone HTML demo, we use navigator.clipboard API if available.
  // This is a demonstration substitute for the Python CLI script.

  // Storage helpers
  function loadSnippets() {
    try {
      const data = localStorage.getItem(snippetsKey);
      if (!data) return {};
      return JSON.parse(data);
    } catch {
      return {};
    }
  }
  function saveSnippets(snippets) {
    localStorage.setItem(snippetsKey, JSON.stringify(snippets));
  }

  // UI helpers
  const outputEl = document.getElementById('output');
  const messageEl = document.getElementById('message');
  const dialogContainer = document.getElementById('dialogContainer');

  function clearMessage() {
    messageEl.textContent = '';
    messageEl.className = '';
  }
  function showMessage(text, type = 'success') {
    messageEl.textContent = text;
    messageEl.className = type;
  }
  function clearOutput() {
    outputEl.textContent = '';
  }
  function showOutput(text) {
    outputEl.textContent = text;
    outputEl.focus();
  }

  // Dialog creation helpers
  function createDialog(title, contentNodes, onConfirm, onCancel, confirmLabel = 'OK', cancelLabel = 'Cancel') {
    dialogContainer.innerHTML = '';
    const dialog = document.createElement('section');
    dialog.setAttribute('role', 'dialog');
    dialog.setAttribute('aria-modal', 'true');
    dialog.setAttribute('aria-labelledby', 'dialogTitle');
    dialog.style.border = '1px solid #ccc';
    dialog.style.padding = '1rem';
    dialog.style.marginTop = '1rem';
    dialog.style.backgroundColor = 'inherit';
    dialog.style.color = 'inherit';
    dialog.tabIndex = -1;

    const titleEl = document.createElement('h2');
    titleEl.id = 'dialogTitle';
    titleEl.textContent = title;
    dialog.appendChild(titleEl);

    contentNodes.forEach(n => dialog.appendChild(n));

    const btnContainer = document.createElement('div');
    btnContainer.style.marginTop = '1rem';
    btnContainer.style.display = 'flex';
    btnContainer.style.gap = '1rem';

    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = confirmLabel;
    confirmBtn.type = 'button';
    confirmBtn.addEventListener('click', () => {
      onConfirm();
      dialogContainer.innerHTML = '';
    });

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = cancelLabel;
    cancelBtn.type = 'button';
    cancelBtn.addEventListener('click', () => {
      if (onCancel) onCancel();
      dialogContainer.innerHTML = '';
      clearMessage();
    });

    btnContainer.appendChild(confirmBtn);
    btnContainer.appendChild(cancelBtn);
    dialog.appendChild(btnContainer);

    dialogContainer.appendChild(dialog);
    confirmBtn.focus();
  }

  // Clipboard helpers (browser simulation)
  async function readClipboard() {
    if (navigator.clipboard && navigator.clipboard.readText) {
      try {
        return await navigator.clipboard.readText();
      } catch {
        return null;
      }
    }
    return null;
  }
  async function writeClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }

  // Core operations
  async function addSnippetFromClipboard() {
    clearMessage();
    clearOutput();
    const clipText = await readClipboard();
    if (!clipText) {
      showMessage('Clipboard is empty or inaccessible.', 'error');
      return;
    }
    const inputName = document.createElement('input');
    inputName.type = 'text';
    inputName.setAttribute('aria-label', 'Snippet name');
    inputName.placeholder = 'Enter snippet name';
    createDialog(
      'Add Snippet from Clipboard',
      [document.createTextNode('Clipboard text detected. Enter a name for this snippet:'), document.createElement('br'), inputName],
      () => {
        const name = inputName.value.trim();
        if (!name) {
          showMessage('Snippet name cannot be empty.', 'error');
          addSnippetFromClipboard();
          return;
        }
        const snippets = loadSnippets();
        if (snippets[name]) {
          if (!confirm(`Snippet "${name}" already exists. Overwrite?`)) {
            addSnippetFromClipboard();
            return;
          }
        }
        snippets[name] = clipText;
        saveSnippets(snippets);
        showMessage(`Snippet "${name}" saved from clipboard.`, 'success');
      },
      () => {
        clearMessage();
      },
      'Save',
      'Cancel'
    );
  }

  function addSnippetFromInput() {
    clearMessage();
    clearOutput();
    const inputName = document.createElement('input');
    inputName.type = 'text';
    inputName.setAttribute('aria-label', 'Snippet name');
    inputName.placeholder = 'Enter snippet name';

    const inputText = document.createElement('textarea');
    inputText.setAttribute('aria-label', 'Snippet text');
    inputText.placeholder = 'Enter snippet text here';

    createDialog(
      'Add Snippet from Typed Input',
      [
        document.createTextNode('Enter a name for the snippet:'),
        document.createElement('br'),
        inputName,
        document.createElement('br'),
        document.createTextNode('Enter the snippet text:'),
        document.createElement('br'),
        inputText,
      ],
      () => {
        const name = inputName.value.trim();
        const text = inputText.value;
        if (!name) {
          showMessage('Snippet name cannot be empty.', 'error');
          addSnippetFromInput();
          return;
        }
        if (!text) {
          showMessage('Snippet text cannot be empty.', 'error');
          addSnippetFromInput();
          return;
        }
        const snippets = loadSnippets();
        if (snippets[name]) {
          if (!confirm(`Snippet "${name}" already exists. Overwrite?`)) {
            addSnippetFromInput();
            return;
          }
        }
        snippets[name] = text;
        saveSnippets(snippets);
        showMessage(`Snippet "${name}" saved from input.`, 'success');
      },
      () => {
        clearMessage();
      },
      'Save',
      'Cancel'
    );
  }

  function listSnippets() {
    clearMessage();
    clearOutput();
    const snippets = loadSnippets();
    const names = Object.keys(snippets);
    if (names.length === 0) {
      showMessage('No snippets saved.', 'warning');
      return;
    }
    showOutput('Saved snippets:\n' + names.map(n => `- ${n}`).join('\n'));
  }

  function retrieveSnippet() {
    clearMessage();
    clearOutput();
    const snippets = loadSnippets();
    const names = Object.keys(snippets);
    if (names.length === 0) {
      showMessage('No snippets to retrieve.', 'warning');
      return;
    }
    const select = document.createElement('select');
    select.setAttribute('aria-label', 'Select snippet to retrieve');
    names.forEach(name => {
      const option = document.createElement('option');
      option.value = name;
      option.textContent = name;
      select.appendChild(option);
    });
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = 'copyToClipboard';
    checkbox.checked = true;
    const label = document.createElement('label');
    label.htmlFor = 'copyToClipboard';
    label.textContent = 'Copy snippet content to clipboard (uncheck to print instead)';

    createDialog(
      'Retrieve Snippet',
      [select, document.createElement('br'), checkbox, label],
      async () => {
        const name = select.value;
        const text = snippets[name];
        if (!text) {
          showMessage(`Snippet "${name}" not found.`, 'error');
          return;
        }
        if (checkbox.checked) {
          const ok = await writeClipboard(text);
          if (ok) {
            showMessage(`Snippet "${name}" copied to clipboard.`, 'success');
            clearOutput();
          } else {
            showMessage('Failed to copy to clipboard.', 'error');
          }
        } else {
          showOutput(`Content of snippet "${name}":\n\n${text}`);
          showMessage('Snippet content printed below.', 'success');
        }
      },
      () => {
        clearMessage();
      },
      'Retrieve',
      'Cancel'
    );
  }

  function deleteSnippet() {
    clearMessage();
    clearOutput();
    const snippets = loadSnippets();
    const names = Object.keys(snippets);
    if (names.length === 0) {
      showMessage('No snippets to delete.', 'warning');
      return;
    }
    const select = document.createElement('select');
    select.setAttribute('aria-label', 'Select snippet to delete');
    names.forEach(name => {
      const option = document.createElement('option');
      option.value = name;
      option.textContent = name;
      select.appendChild(option);
    });
    createDialog(
      'Delete Snippet',
      [document.createTextNode('Select a snippet to delete:'), document.createElement('br'), select],
      () => {
        const name = select.value;
        if (!name) {
          showMessage('No snippet selected.', 'error');
          return;
        }
        if (!confirm(`Are you sure you want to delete snippet "${name}"? This action cannot be undone.`)) {
          showMessage('Deletion cancelled.', 'warning');
          return;
        }
        delete snippets[name];
        saveSnippets(snippets);
        showMessage(`Snippet "${name}" deleted.`, 'success');
        clearOutput();
      },
      () => {
        clearMessage();
      },
      'Delete',
      'Cancel'
    );
  }

  function exportSnippets() {
    clearMessage();
    clearOutput();
    const snippets = loadSnippets();
    const names = Object.keys(snippets);
    if (names.length === 0) {
      showMessage('No snippets to export.', 'warning');
      return;
    }
    const textarea = document.createElement('textarea');
    textarea.readOnly = true;
    textarea.value = JSON.stringify(snippets, null, 2);
    textarea.setAttribute('aria-label', 'Exported JSON snippets');
    createDialog(
      'Export Snippets',
      [
        document.createTextNode('Copy the JSON below to export your snippets.'),
        document.createElement('br'),
        textarea,
      ],
      () => {
        clearMessage();
      },
      () => {
        clearMessage();
      },
      'Close',
      'Close'
    );
    textarea.focus();
    textarea.select();
  }

  function importSnippets() {
    clearMessage();
    clearOutput();
    const textarea = document.createElement('textarea');
    textarea.placeholder = 'Paste JSON snippet data here';
    textarea.setAttribute('aria-label', 'Paste JSON snippet data for import');
    createDialog(
      'Import Snippets',
      [
        document.createTextNode('Paste JSON snippet data to import. Existing snippets with the same name will be overwritten after confirmation.'),
        document.createElement('br'),
        textarea,
      ],
      () => {
        let imported = null;
        try {
          imported = JSON.parse(textarea.value);
        } catch {
          showMessage('Invalid JSON format.', 'error');
          importSnippets();
          return;
        }
        if (typeof imported !== 'object' || imported === null) {
          showMessage('Imported data must be a JSON object.', 'error');
          importSnippets();
          return;
        }
        const snippets = loadSnippets();
        const keys = Object.keys(imported);
        if (keys.length === 0) {
          showMessage('No snippets found in imported data.', 'warning');
          return;
        }
        // Confirm overwrite for existing keys
        const existingKeys = keys.filter(k => snippets[k]);
        if (existingKeys.length > 0) {
          if (!confirm(`Imported data contains ${existingKeys.length} snippet(s) that will overwrite existing ones:\n${existingKeys.join(', ')}\nProceed?`)) {
            showMessage('Import cancelled.', 'warning');
            return;
          }
        }
        keys.forEach(k => {
          snippets[k] = imported[k];
        });
        saveSnippets(snippets);
        showMessage(`Imported ${keys.length} snippet(s).`, 'success');
      },
      () => {
        clearMessage();
      },
      'Import',
      'Cancel'
    );
  }

  // Attach event listeners
  document.getElementById('addClipboardBtn').addEventListener('click', addSnippetFromClipboard);
  document.getElementById('addInputBtn').addEventListener('click', addSnippetFromInput);
  document.getElementById('listBtn').addEventListener('click', listSnippets);
  document.getElementById('retrieveBtn').addEventListener('click', retrieveSnippet);
  document.getElementById('deleteBtn').addEventListener('click', deleteSnippet);
  document.getElementById('exportBtn').addEventListener('click', exportSnippets);
  document.getElementById('importBtn').addEventListener('click', importSnippets);

  // Keyboard navigation: focus cycles through menu buttons
  const menuButtons = Array.from(document.querySelectorAll('#menu button'));
  menuButtons.forEach((btn, i) => {
    btn.addEventListener('keydown', e => {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        menuButtons[(i + 1) % menuButtons.length].focus();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        menuButtons[(i - 1 + menuButtons.length) % menuButtons.length].focus();
      }
    });
  });

  // Initial message
  showMessage('Ready. Use the menu above to manage snippets.', 'success');
})();
</script>
</body>
</html>